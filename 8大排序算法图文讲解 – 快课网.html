<!DOCTYPE>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=10,IE=9,IE=8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0">
<title>8大排序算法图文讲解 – 快课网</title>
<script>
window._deel = {name: '快课网',url: 'http://www.cricode.com/wp-content/themes/yusi2.0', ajaxpager: 'on', commenton: 1, roll: [3,]}
</script>
<link rel="stylesheet" id="crayon-css" href="8%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9B%BE%E6%96%87%E8%AE%B2%E8%A7%A3%20%E2%80%93%20%E5%BF%AB%E8%AF%BE%E7%BD%91_files/crayon.css" type="text/css" media="all">
<link rel="stylesheet" id="style-css" href="8%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9B%BE%E6%96%87%E8%AE%B2%E8%A7%A3%20%E2%80%93%20%E5%BF%AB%E8%AF%BE%E7%BD%91_files/style.css" type="text/css" media="all">
<script type="text/javascript" src="8%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9B%BE%E6%96%87%E8%AE%B2%E8%A7%A3%20%E2%80%93%20%E5%BF%AB%E8%AF%BE%E7%BD%91_files/jquery.js"></script>
<script type="text/javascript">
/* <![CDATA[ */
var CrayonSyntaxSettings = {"version":"2.6.5","is_admin":"0","ajaxurl":"http:\/\/www.cricode.com\/wp-admin\/admin-ajax.php","prefix":"crayon-","setting":"crayon-setting","selected":"crayon-setting-selected","changed":"crayon-setting-changed","special":"crayon-setting-special","orig_value":"data-orig-value","debug":""};
var CrayonSyntaxStrings = {"copy":"\u4f7f\u7528 %s \u590d\u5236\uff0c\u4f7f\u7528 %s \u7c98\u8d34\u3002","minimize":"Click To Expand Code"};
/* ]]> */
</script>
<script type="text/javascript" src="8%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9B%BE%E6%96%87%E8%AE%B2%E8%A7%A3%20%E2%80%93%20%E5%BF%AB%E8%AF%BE%E7%BD%91_files/crayon.js"></script>
<link rel="prev" title="位运算及相关面试题汇总" href="http://www.cricode.com/3193.html">
<link rel="canonical" href="http://www.cricode.com/3212.html">
<link rel="shortlink" href="http://www.cricode.com/?p=3212">
<meta name="keywords" content="数据结构, 算法, 数据结构-算法">
<meta name="description" content="排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。 常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。 本文将依次介绍上述八大排序算法。  算法一：插入排序 &nbsp;  插入排序示意图 插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序">
<!--[if lt IE 9]><script src="http://www.cricode.com/wp-content/themes/yusi2.0/js/html5.js"></script><![endif]-->
<script src="8%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9B%BE%E6%96%87%E8%AE%B2%E8%A7%A3%20%E2%80%93%20%E5%BF%AB%E8%AF%BE%E7%BD%91_files/share.js"></script><link type="text/css" rel="styleSheet" href="8%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9B%BE%E6%96%87%E8%AE%B2%E8%A7%A3%20%E2%80%93%20%E5%BF%AB%E8%AF%BE%E7%BD%91_files/share.css"><script>try {  for(var lastpass_iter=0; lastpass_iter < document.forms.length; lastpass_iter++){    var lastpass_f = document.forms[lastpass_iter];    if(typeof(lastpass_f.lpsubmitorig)=="undefined"){      if (typeof(lastpass_f.submit) == "function") {        lastpass_f.lpsubmitorig = lastpass_f.submit;        lastpass_f.submit = function(){          var form = this;          try {            if (document.documentElement && 'createEvent' in document)            {              var forms = document.getElementsByTagName('form');              for (var i=0 ; i<forms.length ; ++i)                if (forms[i]==form)                {                  var element = document.createElement('lpformsubmitdataelement');                  element.setAttribute('formnum',i);                  element.setAttribute('from','submithook');                  document.documentElement.appendChild(element);                  var evt = document.createEvent('Events');                  evt.initEvent('lpformsubmit',true,false);                  element.dispatchEvent(evt);                  break;                }            }          } catch (e) {}          try {            form.lpsubmitorig();          } catch (e) {}        }      }    }  }} catch (e) {}</script></head>
<body class="single single-post postid-3212 single-format-standard">

<header id="header" class="header">
<div class="container-inner">
 
</div>

	<div id="nav-header" class="navbar fixed">
		
<li style="float:right;">
                    <div class="toggle-search"><i class="fa fa-search"></i></div>
<div class="search-expand" style="display: none;"><div class="search-expand-inner"><form method="get" class="searchform themeform" onsubmit="location.href='http://www.cricode.com/search/' + encodeURIComponent(this.s.value).replace(/%20/g, '+'); return false;" action="/"><div> <input class="search" name="s" onblur="if(this.value=='')this.value='search...';" onfocus="if(this.value=='search...')this.value='';" value="search..." type="ext"></div></form></div></div>
</li>
		</ul><div class="screen-mini"><button data-type="screen-nav" class="btn btn-inverse screen-nav"><i class="fa fa-list"></i></button></div>
	</div>
	
</header>
<section class="container"><div class="speedbar">
					
				
	</div>
	<div class="content-wrap">
	<div class="content">

				<header class="article-header">
			<h1 class="article-title"><a href="http://www.cricode.com/3212.html">8大排序算法图文讲解</a></h1>
			<div class="meta">
				
		</header>
<div class="banner banner-post"><script async="" src="8%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9B%BE%E6%96%87%E8%AE%B2%E8%A7%A3%20%E2%80%93%20%E5%BF%AB%E8%AF%BE%E7%BD%91_files/adsbygoogle.js"></script>
<!-- singer_bottom -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4367320306096191" data-ad-slot="3990591264"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>		<article class="article-content">
			<p style="color: #555555;">排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</p>
<p style="color: #555555;">常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</p>
<p style="color: #555555;">本文将依次介绍上述八大排序算法。</p>
<h2>算法一：<span style="color: #555555;">插入排序</span></h2>
<p>&nbsp;</p>
<p style="text-align: center;"><img class="alignnone" src="8%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9B%BE%E6%96%87%E8%AE%B2%E8%A7%A3%20%E2%80%93%20%E5%BF%AB%E8%AF%BE%E7%BD%91_files/insert-sort.gif" alt="" height="180" width="300"></p>
<p style="text-align: center;">插入排序示意图</p>
<p style="text-align: left;">插入排序是一种最简单直观的排序算法，<span style="color: #252525;">它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</span></p>
<p style="text-align: left;"><strong><span style="color: #252525;"><strong style="color: #555555;">算法步骤</strong>：</span></strong></p>
<p style="text-align: left;">1）将第一待排序序列第一个元素看做一个<span style="color: #ff0000;">有序序列</span>，把第二个元素到最后一个元素当成是<span style="color: #ff0000;">未排序序列</span>。</p>
<p style="text-align: left;">2）从头到尾依次扫描<span style="color: #ff0000;">未排序序列</span>，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>
<h2>算法二：希尔排序</h2>
<p style="text-align: center;"><img class="aligncenter" src="8%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9B%BE%E6%96%87%E8%AE%B2%E8%A7%A3%20%E2%80%93%20%E5%BF%AB%E8%AF%BE%E7%BD%91_files/shellsort_anim.gif" alt="" height="344" width="277">希尔排序示意图</p>
<p>&nbsp;</p>
<p style="color: #252525;"><b>希尔排序</b>，也称<b>递减增量排序算法</b>，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p>
<p style="color: #252525;">希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到<a data-original-title="线性排序（页面不存在）" class="new" style="color: #a55858;" title="" href="http://zh.wikipedia.org/w/index.php?title=%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F&amp;action=edit&amp;redlink=1">线性排序</a>的效率</li>
<li>但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位</li>
</ul>
<p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<p><strong style="color: #555555;">算法步骤</strong>：</p>
<p>1）选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</p>
<p>2）按增量序列个数k，对序列进行k 趟排序；</p>
<p>3）每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
<p>&nbsp;</p>
<h2>算法三：选择排序</h2>
<p><img class="aligncenter" src="8%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9B%BE%E6%96%87%E8%AE%B2%E8%A7%A3%20%E2%80%93%20%E5%BF%AB%E8%AF%BE%E7%BD%91_files/selection_sort_animation.gif" alt="" height="288" width="288"></p>
<p style="text-align: center;">选择排序示意图</p>
<p style="text-align: left;"><b style="color: #252525;">选择排序</b><span style="color: #252525;">(Selection sort)也是一种简单直观的</span>排序算法<span style="color: #252525;">。</span></p>
<p style="text-align: left;"><span style="color: #252525;"><strong style="color: #555555;">算法步骤</strong>：</span></p>
<p style="text-align: left;"><span style="color: #252525;">1）首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</span></p>
<p style="text-align: left;"><span style="color: #252525;">2）再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</span></p>
<p style="text-align: left;"><span style="color: #252525;">3）重复第二步，直到所有元素均排序完毕。</span></p>
<p>&nbsp;</p>
<h2>算法四：冒泡排序</h2>
<p><img class="aligncenter" src="8%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9B%BE%E6%96%87%E8%AE%B2%E8%A7%A3%20%E2%80%93%20%E5%BF%AB%E8%AF%BE%E7%BD%91_files/bubble_sort_animation.gif" alt="" height="237" width="280"></p>
<p style="text-align: center;">冒泡排序示意图</p>
<p>&nbsp;<b style="color: #252525;">冒泡排序</b><span style="color: #252525;">（</span><b style="color: #252525;">Bubble Sort</b><span style="color: #252525;">）也是一种简单直观的</span>排序算法<span style="color: #252525;">。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</span></p>
<p style="color: #252525;"><strong style="color: #555555;">算法步骤</strong>：</p>
<p>1）比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
<p>2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
<p>3）针对所有的元素重复以上的步骤，除了最后一个。</p>
<p>4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<p>&nbsp;</p>
<h2>算法五：归并排序</h2>
<p><img class="aligncenter" src="8%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9B%BE%E6%96%87%E8%AE%B2%E8%A7%A3%20%E2%80%93%20%E5%BF%AB%E8%AF%BE%E7%BD%91_files/merge_sort_animation2.gif" alt="" height="237" width="280"></p>
<p style="text-align: center;">归并排序示意图</p>
<p style="color: #555555;"><b>归并排序（Merge&nbsp;sort）</b>是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide&nbsp;and&nbsp;Conquer）的一个非常典型的应用。</p>
<p style="color: #555555;"><strong>算法步骤：</strong></p>
<p style="color: #555555;">1.&nbsp;申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</p>
<p style="color: #555555;">2.&nbsp;设定两个指针，最初位置分别为两个已经排序序列的起始位置</p>
<p style="color: #555555;">3.&nbsp;比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</p>
<p style="color: #555555;">4.&nbsp;重复步骤3直到某一指针达到序列尾</p>
<p style="color: #555555;">5.&nbsp;将另一序列剩下的所有元素直接复制到合并序列尾</p>
<p><b style="color: #555555;">详细介绍：</b><a style="color: #00a67c;" title="" href="http://cricode.com/1333.html" target="_blank" data-original-title=""><b>归并</b><b>排序</b></a></p>
<h2>算法六：快速排序</h2>
<p><img class="aligncenter" src="8%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9B%BE%E6%96%87%E8%AE%B2%E8%A7%A3%20%E2%80%93%20%E5%BF%AB%E8%AF%BE%E7%BD%91_files/Sorting_quicksort_anim.gif" alt="" height="214" width="280"></p>
<p style="text-align: center;">快速排序示意图</p>
<p style="color: #555555;"><b>快速排序</b>是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序&nbsp;<i>n</i>&nbsp;个项目要<b>Ο</b>(<i>n</i>&nbsp;log&nbsp;<i>n</i>)次比较。在最坏状况下则需要<b>Ο</b>(<i>n</i>2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他<b>Ο</b>(<i>n</i>&nbsp;log&nbsp;<i>n</i>)&nbsp;算法更快，因为它的内部循环（inner&nbsp;loop）可以在大部分的架构上很有效率地被实现出来。</p>
<p style="color: #555555;">快速排序使用分治法（Divide&nbsp;and&nbsp;conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p>
<p style="color: #555555;"><strong>算法步骤：</strong></p>
<p style="color: #555555;">1&nbsp;从数列中挑出一个元素，称为&nbsp;“基准”（pivot），</p>
<p style="color: #555555;">2&nbsp;重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为<b>分区（partition）</b>操作。</p>
<p style="color: #555555;">3&nbsp;递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
<p style="color: #555555;">递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<p><b style="color: #555555;">详细介绍：<a style="color: #00a67c;" title="" href="http://cricode.com/970.html" target="_blank" data-original-title="">快速排序</a></b></p>
<h2>算法七：堆排序</h2>
<p><img class="aligncenter" src="8%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9B%BE%E6%96%87%E8%AE%B2%E8%A7%A3%20%E2%80%93%20%E5%BF%AB%E8%AF%BE%E7%BD%91_files/Sorting_heapsort_anim.gif" alt="" height="214" width="280"></p>
<p style="text-align: center;">堆排序示意图</p>
<p style="color: #555555;"><b>堆排序</b>（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足<i>堆积的性质</i>：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p style="color: #555555;">堆排序的平均时间复杂度为<b>Ο</b>(<i>n</i>log<i>n</i>) 。</p>
<p style="color: #555555;"><strong>算法步骤：</strong></p>
<p>1）创建一个堆H[0..n-1]</p>
<p>2）把堆首（最大值）和堆尾互换</p>
<p style="color: #555555;">3）把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置</p>
<p style="color: #555555;">4）&nbsp;重复步骤2，直到堆的尺寸为1</p>
<p><b style="color: #555555;">详细介绍：<a style="color: #00a67c;" title="" href="http://cricode.com/977.html" target="_blank" data-original-title="">堆排序</a></b></p>
<h2>算法八：基数排序</h2>
<p><b style="color: #252525;">基数排序</b><span style="color: #252525;">是一种<span style="color: #ff0000;">非比较型</span></span>整数排序算法<span style="color: #252525;">，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</span></p>
<p>说基数排序之前，我们简单介绍桶排序：</p>
<p><strong>算法思想：</strong>是将阵列分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递回方式继续使
用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 
比较排序，他不受到 O(n log n) 下限的影响。<br>
简单来说，就是把数据分组，放在一个个的桶中，然后对每个桶里面的在进行排序。</p>
<p>例如要对大小为[1..1000]范围内的n个整数A[1..n]排序</p>
<p>首先，可以把桶设为大小为10的范围，具体而言，设集合B[1]存储[1..10]的整数，集合B[2]存储 &nbsp; 
(10..20]的整数，……集合B[i]存储( &nbsp; (i-1)*10, &nbsp; i*10]的整数，i &nbsp; = 
&nbsp; 1,2,..100。总共有&nbsp; 100个桶。</p>
<p>然后，对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。&nbsp; 再对这100个桶中每个桶里的数字排序，这时可用冒泡，选择，乃至快排，一般来说任&nbsp; 何排序法都可以。</p>
<p>最后，依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这&nbsp; 样就得到所有数字排好序的一个序列了。</p>
<p>假设有n个数字，有m个桶，如果数字是平均分布的，则每个桶里面平均有n/m个数字。如果</p>
<p>对每个桶中的数字采用快速排序，那么整个算法的复杂度是</p>
<p>O(n&nbsp;&nbsp; + &nbsp; m &nbsp; * &nbsp; n/m*log(n/m)) &nbsp; = &nbsp; O(n&nbsp;&nbsp; + &nbsp; nlogn &nbsp; – &nbsp; nlogm)</p>
<p>从上式看出，当m接近n的时候，桶排序复杂度接近O(n)</p>
<p>当然，以上复杂度的计算是基于输入的n个数字是平均分布这个假设的。这个假设是很强的&nbsp; ，实际应用中效果并没有这么好。如果所有的数字都落在同一个桶中，那就退化成一般的排序了。</p>
<p>前面说的几大排序算法 ，大部分时间复杂度都是O（n2），也有部分排序算法时间复杂度是O(nlogn)。而桶式排序却能实现O（n）的时间复杂度。但桶排序的缺点是：</p>
<p>1）首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。</p>
<p>2）其次待排序的元素都要在一定的范围内等等。</p>
<p>&nbsp;</p>
<h2>&nbsp;总结</h2>
<p>各种排序的稳定性，时间复杂度、空间复杂度、稳定性总结如下图：</p>
<p><img class="aligncenter" src="8%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9B%BE%E6%96%87%E8%AE%B2%E8%A7%A3%20%E2%80%93%20%E5%BF%AB%E8%AF%BE%E7%BD%91_files/sort_table.jpg" alt="" height="286" width="600"></p>
<p>&nbsp;</p>
<p><strong>关于时间复杂度：</strong></p>
<p><span lang="EN">(1)</span>平方阶<span lang="EN">(O(n</span><sup><span lang="EN">2</span></sup><span lang="EN">))排序</span><br>
各类简单排序:直接插入、直接选择和冒泡排序；</p>
<p><span lang="EN">(2)</span>线性对数阶<span lang="EN">(O(nlog2n))排序<br>
</span>　　快速排序、堆排序和归并排序；<span lang="EN"><br>
</span><span lang="EN">(3)</span><span lang="EN">O(n<sup>1+§</sup>))排序,</span>§是介于<span lang="EN">0和1之间的常数。</span></p>
<p><span lang="EN">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 希尔排序<br>
</span><span lang="EN">(4)</span>线性阶<span lang="EN">(O(n))排序</span><br>
基数排序，此外还有桶、箱排序。</p>
<p>&nbsp;</p>
<p><strong>关于稳定性：</strong></p>
<p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序</p>
<p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序</p>
<p>&nbsp;</p>


      

	</article>	
				
	

	</div>
				<div id="comment-ad" class="banner banner-related"><script async="" src="8%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9B%BE%E6%96%87%E8%AE%B2%E8%A7%A3%20%E2%80%93%20%E5%BF%AB%E8%AF%BE%E7%BD%91_files/adsbygoogle.js"></script>
<!-- related_article -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4367320306096191" data-ad-slot="3233711663"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>		<div id="respond" class="no_webshot">
		<form action="http://www.cricode.com/wp-comments-post.php" method="post" id="commentform">
		
		<div class="comt-title">
			
		
	<input id="ak_js" name="ak_js" value="1408351087398" type="hidden"></form>
	</div>
			</div>
</div>
<aside class="sidebar">	



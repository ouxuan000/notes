* springboot实战
** springboot2.0.6
** 参考springboot实战
** 开发环境初始化
   + start.spring.io 填入相关以来后下载
   + spring-boot-cli工具
     + archlinux  yaourt -S spring-boot-cli
     + 一个简单的web项目(groovy)
       #+BEGIN_SRC groovy
         @RestController
         public class HelloController {

             @RequestMapping(value = "/hello")
             public String sayHello() {
                 return "Hello，Spring Boot！";
             }
         }
       #+END_SRC
       + spring run hello.groovy 运行即可访问http://localhost:8080/hello
     + help 指令可以获取更多对指令的帮助信息
       + spring help run
     + 当前目录下 *.groovy 文件打包成可执行的 jar 文件：
       + spring jar myapp.jar  *.groovy
     + 初始化一个web项目
       + 用来查看springboot支持哪些自动依赖
         + spring init --list 
       + 初始化项目并指定依赖
         + spring init --dependencies=web,data-jpa my-project 
       + spring init 默认压缩包都为demo.zip, 可以使用下面命令直接解压到指定目录
         spring init -x myapp
** springboot自动化配置
   + springbootautoconfig.jar
   + 自定义condition
   + spring4开始的条件配置
** 自定义配置
   + spring-boot-security默认会校验一个单用户登录， 需要自定义覆盖其实现
** springboot自动化测试
*** 浏览器篇
    + 下载chrome驱动
      + http://chromedriver.storage.googleapis.com/index.html?path=70.0.3538.67/
    + 下载chrome浏览器，版本与驱动对应
    + gradle中引入	testCompile("org.seleniumhq.selenium:selenium-java")
    + 编写测试类
    + 具体参考项目中com.lx.demo.readinglist.ChromeWebTest  
*** mockmvc
    + com.lx.demo.readinglist.MockMvcWebTests
*** reset篇
    + org.springframework.boot.test.context.SpringBootTest
** Groovy与 Spring Boot CLI
   + springboot cli的自动依赖及自动依赖后的自动配置(编译错误来触发自动依赖解析)
     #+BEGIN_EXAMPLE
     通过Spring Boot CLI运行阅读列表应用程序，表面看似平凡无奇，实则大有乾坤。CLI尝试
 用内嵌的Groovy编译器来编译Groovy代码。虽然你不知道，但实际上，未知类型（比如
 JdbcTemplate 、 Controller 及 RequestMapping ，等等）最终会使代码编译失败。
 但CLI不会放弃，它知道只要把Spring Boot JDBC起步依赖加入Classpath就能找到
 JdbcTemplate 。它还知道把Spring Boot的Web起步依赖加入Classpath就能找到Spring MVC的相
 关类。因此，CLI会从Maven仓库（默认为Maven中心仓库）里获取那些依赖。
 如果此时CLI重新编译，那还是会失败，因为缺少 import 语句。但CLI知道很多常用类的包。
 利用定制Groovy编译器默认包导入的功能之后，CLI把所有需要用到的包都加入了Groovy编译器
 的默认导入列表。
 现在CLI可以尝试再一次编译了。假设没有其他CLI能力范围外的问题（比如，存在CLI不知
 道的语法或类型错误），代码就能完成编译。CLI将通过内置的启动方法（与基于Java的例子里的
 main() 方法类似）运行应用程序。
 此时，Spring Boot自动配置就能发挥作用了。它发现Classpath里存在Spring MVC（因为CLI
 解析了Web起步依赖），就自动配置了合适的Bean来支持Spring MVC，还有嵌入式Tomcat Bean供
 应用程序使用。它还发现Classpath里有 JdbcTemplate ，所以自动创建了 JdbcTemplate Bean，
 注入了同样自动创建的 DataSource Bean。
 说起 DataSource Bean，这只是Spring Boot自动配置创建的众多Bean中的一个。Spring Boot
 还自动配置了很多Bean来支持Spring MVC中的Thymeleaf模板。正是由于我们使用 @Grab 注解向
 Classpath里添加了H2和Thymeleaf，这才触发了针对嵌入式H2数据库和Thymeleaf的自动配置。
 @Grab 注解的作用是方便添加CLI无法自动解析的依赖。虽然它看上去很简单，但实际上这
 个小小的注解作用远比你想象得要大。
     #+END_EXAMPLE
   + springboot启动groovy程序
     + 进入当且项目根目录 
     + spring run .
     + 浏览器访问 http://localhost:8080
   + springboot 打包可执行程序
     + 进入项目根目录
     + spring jar readlist.jar .
     + java -jar readlist.jar
     + 浏览器访问:http://localhost:8080
* springboot自定义路径&springboot中多
** org.springframework.web.servlet.view.InternalResourceViewResolver
   + https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html
   #+BEGIN_EXAMPLE
   <bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/>
        <property name="prefix" value="/WEB-INF/jsp/"/>
        <property name="suffix" value=".jsp"/>
    </bean>
   #+END_EXAMPLE
   未结合springboot时， 可以通过上述配置来跳转页面
** springboot中的默认路径及自定义成上述路径
   + https://blog.csdn.net/u010502101/article/details/78867730
   + spring-configuration-metadata.json (在idea项目中搜索 spring.mvc.view.prefix)
     + org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration
       + 这个里面设置读取跳转页面的前缀后缀
** 采用代码实现分别采用servlet, springmvc, springboot访问web-inf/jsp下的index.jsp页面
* Spring Boot JDBC
* Spring Boot 实际使用场景
* 多个web服务依赖
  + 题外话：在 Spring Boot 2.0.0 ，如果应用采用 Spring Web MVC 作为 Web 服务， 默认情况下，使用 嵌入式 Tomcat。
  + 如果采用Spring Web Flux，默认情况下，使用 Netty Web Server（嵌入式）
  + 从 Spring Boot 1.4 支持 FailureAnalysisReporter 实现
  + WebFlux
  +
  +  Mono : 0 - 1 Publisher（类似于Java 8 中的 Optional）
  + 
  +  Flux:     0 - N Publisher（类似于Java 中的 List）
  + 
  +  传统的 Servlet 采用 HttpServletRequest、HttpServletResponse
  + 
  +  WebFlux 采用：ServerRequest、ServerResponse（不再限制于 Servlet 容器，可以选择自定义实现，比如 Netty Web Server）



### 单数据源的场景



#### 数据连接池技术



##### [Apache Commons DBCP](http://commons.apache.org/proper/commons-dbcp/)

 *  commons-dbcp2 

     * 依赖：commons-pool2

* commons-dbcp（老版本）

  * 依赖：commons-pool

  ​

##### [Tomcat DBCP](http://tomcat.apache.org/tomcat-8.5-doc/jndi-datasource-examples-howto.html)



## 事务

### 重要感念



#### 自动提交模式

#### 事务隔离级别（Transaction isolation levels）

* TRANSACTION_READ_UNCOMMITTED
* TRANSACTION_READ_COMMITTED
* TRANSACTION_REPEATABLE_READ
* TRANSACTION_SERIALIZABLE

从上至下，级别越高，性能越差



Spring Transaction 实现重用了 JDBC API：

Isolation -> TransactionDefinition 

* ISOLATION_READ_UNCOMMITTED = Connection.TRANSACTION_READ_UNCOMMITTED
* ISOLATION_READ_COMMITTED = Connection.TRANSACTION_READ_COMMITTED
* ISOLATION_REPEATABLE_READ = Connection.TRANSACTION_REPEATABLE_READ
* ISOLATION_SERIALIZABLE = Connection.TRANSACTION_SERIALIZABLE

#### 保护点（Savepoints）



save(){

 // 建立一个SP 1

 SP 1

 SP 2 {

  // 操作

} catch(){

 rollback(SP2);

}

commit();

release(SP1);

}





#### @Transaction 

##### 代理执行 - `TransactionInterceptor`

 * 可以控制 rollback 的异常粒度：rollbackFor() 以及 noRollbackFor()
* 可以执行 事务管理器：transactionManager()



#### 通过 API 方式进行事务处理 - PlatformTransactionManager





线程 1:

调用 save ->

@Transactional T1 save() 控制 DS 1 insert -> 



 save2() DS 1 insert



@Transactional

save() {

  //insert DS1 

  save2() // insert DS1, 没有Transactional

}



@Transactional(NESTED)

save2(){

}





### 问题集合



#### 1. 用reactive web，原来mvc的好多东西都不能用了？

答：不是， Reactive Web 还是能够兼容 Spring WebMVC

#### 2. 开个线程池事务控制用API方式？比如开始写的Excutor.fixExcutor(5)

答：TransactionSynchronizationManager 使用大量的ThreadLocal 来实现的



#### 3. 假设一个service方法给了@Transaction标签，在这个方法中还有其他service 的某个方法，这个方法没有加@Transaction，那么如果内部方法报错，会回滚吗？

答：会的，当然可以过滤掉一些不关紧要的异常noRollbackFor()



#### 4. spring 分布式事务 生产环境实现方式有哪些?

答：https://docs.spring.io/spring-boot/docs/2.0.0.M5/reference/htmlsingle/#boot-features-jta



* springboot2.0.6
* 参考springboot实战
* 开发环境初始化
  + start.spring.io 填入相关以来后下载
  + spring-boot-cli工具
    + archlinux  yaourt -S spring-boot-cli
    + 一个简单的web项目(groovy)
      #+BEGIN_SRC groovy
        @RestController
        public class HelloController {

            @RequestMapping(value = "/hello")
            public String sayHello() {
                return "Hello，Spring Boot！";
            }
        }
      #+END_SRC
      + spring run hello.groovy 运行即可访问http://localhost:8080/hello
    + help 指令可以获取更多对指令的帮助信息
      + spring help run
    + 当前目录下 *.groovy 文件打包成可执行的 jar 文件：
      + spring jar myapp.jar  *.groovy
    + 初始化一个web项目
      + 用来查看springboot支持哪些自动依赖
        + spring init --list 
      + 初始化项目并指定依赖
        + spring init --dependencies=web,data-jpa my-project 
      + spring init 默认压缩包都为demo.zip, 可以使用下面命令直接解压到指定目录
        spring init -x myapp
* springboot自动化配置
  + springbootautoconfig.jar
  + 自定义condition
  + spring4开始的条件配置
* 自定义配置
  + spring-boot-security默认会校验一个单用户登录， 需要自定义覆盖其实现
* springboot自动化测试
** 浏览器篇
   + 下载chrome驱动
     + http://chromedriver.storage.googleapis.com/index.html?path=70.0.3538.67/
   + 下载chrome浏览器，版本与驱动对应
   + gradle中引入	testCompile("org.seleniumhq.selenium:selenium-java")
   + 编写测试类
   + 具体参考项目中com.lx.demo.readinglist.ChromeWebTest  
** mockmvc
   + com.lx.demo.readinglist.MockMvcWebTests
** reset篇
   + org.springframework.boot.test.context.SpringBootTest
* Groovy与 Spring Boot CLI
  + springboot cli的自动依赖及自动依赖后的自动配置(编译错误来触发自动依赖解析)
    #+BEGIN_EXAMPLE
    通过Spring Boot CLI运行阅读列表应用程序，表面看似平凡无奇，实则大有乾坤。CLI尝试
用内嵌的Groovy编译器来编译Groovy代码。虽然你不知道，但实际上，未知类型（比如
JdbcTemplate 、 Controller 及 RequestMapping ，等等）最终会使代码编译失败。
但CLI不会放弃，它知道只要把Spring Boot JDBC起步依赖加入Classpath就能找到
JdbcTemplate 。它还知道把Spring Boot的Web起步依赖加入Classpath就能找到Spring MVC的相
关类。因此，CLI会从Maven仓库（默认为Maven中心仓库）里获取那些依赖。
如果此时CLI重新编译，那还是会失败，因为缺少 import 语句。但CLI知道很多常用类的包。
利用定制Groovy编译器默认包导入的功能之后，CLI把所有需要用到的包都加入了Groovy编译器
的默认导入列表。
现在CLI可以尝试再一次编译了。假设没有其他CLI能力范围外的问题（比如，存在CLI不知
道的语法或类型错误），代码就能完成编译。CLI将通过内置的启动方法（与基于Java的例子里的
main() 方法类似）运行应用程序。
此时，Spring Boot自动配置就能发挥作用了。它发现Classpath里存在Spring MVC（因为CLI
解析了Web起步依赖），就自动配置了合适的Bean来支持Spring MVC，还有嵌入式Tomcat Bean供
应用程序使用。它还发现Classpath里有 JdbcTemplate ，所以自动创建了 JdbcTemplate Bean，
注入了同样自动创建的 DataSource Bean。
说起 DataSource Bean，这只是Spring Boot自动配置创建的众多Bean中的一个。Spring Boot
还自动配置了很多Bean来支持Spring MVC中的Thymeleaf模板。正是由于我们使用 @Grab 注解向
Classpath里添加了H2和Thymeleaf，这才触发了针对嵌入式H2数据库和Thymeleaf的自动配置。
@Grab 注解的作用是方便添加CLI无法自动解析的依赖。虽然它看上去很简单，但实际上这
个小小的注解作用远比你想象得要大。
    #+END_EXAMPLE
  + springboot启动groovy程序
    + 进入当且项目根目录 
    + spring run .
    + 浏览器访问 http://localhost:8080
  + springboot 打包可执行程序
    + 进入项目根目录
    + spring jar readlist.jar .
    + java -jar readlist.jar
    + 浏览器访问:http://localhost:8080

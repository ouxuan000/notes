* 啥是spring, 及spring中一些名词解释
  Spring是一个开源的轻量级JavaSE（Java标准版本）/JavaEE（Java企业版本）开发应用框架，其目的是用于简化企业级应用程序开发。应用程序是由一组相互协作的对象组成。而在传统应用程序开发中，一个完整的应用是由一组相互协作的对象组成。所以开发一个应用除了要开发业务逻辑之外，最多的是关注如何使这些对象协作来完成所需功能，而且要低耦合、高内聚。业务逻辑开发是不可避免的， 那如果有个框架出来帮我们来创建对象及管理这些对象之间的依赖关系。可能有人说了，比如“抽象工厂、工厂方法设计模式”不也可以帮我们创建对象，“生成器模式”帮我们处理对象间的依赖关系，不也能完成这些功能吗？可是这些又需要我们创建另一些工厂类、生成器类，我们又要而外管理这些类，增加了我们的负担，如果能有种通过配置方式来创建对象，管理对象之间依赖关系，我们不需要通过工厂和生成器来创建及管理对象之间的依赖关系，这样我们是不是减少了许多工作，加速了开发，能节省出很多时间来干其他事。Spring框架刚出来时主要就是来完成这个功能。
  
  Spring框架除了帮我们管理对象及其依赖关系，还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，还能帮我管理最头疼的数据库事务，本身提供了一套简单的JDBC访问实现， 提供与第三方数据访问框架集成（如Hibernate、JPA），与各种JavaEE技术整合（如JavaMail、任务调度等等），提供一套自己的web层框架SpringMVC、而且还能非常简单的与第三方Web框架集成。从这里我们可以认为Spring是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力，从而使我们可以更自由的选择到底使用什么技术进行开发。而且不管是JAVASE（C/S架构）应用程序还是JAVAEE（B/S架构）应用程序都可以使用这个平台进行开发。
** 从bean开始
   1996，Java还只是一个新兴的、初出茅庐的编程语言。人们之所以关注她仅仅是因为，可以使用
   Java的Applet来开发Web应用。但这些开发者很快就发现这个新兴的语言还能做更多的事情。与之前的所有语言不同，Java让模块化构建复杂的系统成为可能（当时的软件行业虽然在业务上突飞猛进，但当时开发用的是传统的面向过程开发思想，软件的开发效率一直踟蹰不前。伴随着业务复杂性的不断加深，开发也变得越发困难。其实，当时也是面向对象思想飞速发展的时期，她在80年代末被提出，成熟于90年代，现今大多数编程语言都是面向对象的，当然这是后话了）。他们为Applet而来，为组件化而留。这便是最早的Java。

   同样在这一年的12月，Sun公司发布了当时还名不见经传但后来人尽皆知的JavaBean1.00-A规范。早期的JavaBean规范针对于Java，她定义了软件组件模型。这个规范规定了一整套编码策略，使简单的Java对象不仅可以被重用，而且还可以轻松地构建更为复杂的应用。尽管JavaBean最初是为重用应用组件而设计的，但当时他们却是主要用作构建窗体控件，毕竟在PC时代那才是主流。但相比于当时正如日中天的Delphi、VB和C++，他看起来还是太简易了，以至于无法胜任任何"实际的"工作。
   尽管现实中有很多系统是基于EJB构建的，但EJB从来没有实现它最初的设想：简化开发。EJB的声明式编程模型的确简化了很多基础架构层面的开发，例如事务和安全；但另一方面EJB在部署描述符和配套代码实现等方面变得异常复杂。随着时间的推移，很多开发者对EJB已经不再抱有幻想，开始寻求更简洁的方法。
   现在Java组件开发理念重新回归正轨。新的编程技术AOP和DI的不断出现，他们为JavaBean提供了之前EJB才能拥有的强大功能。这些技术为POJO提供了类似EJB的声明式编程模型，而没有引入任何EJB的复杂性。当简单的JavaBean足以胜任时，人们便不愿编写笨重的EJB组件了。
   客观地讲，EJB的发展甚至促进了基于POJO的编程模型。引入新的理念，最新的EJB规范相比之前的规范有了前所未有的简化，但对很多开发者而言，这一切的一切都来得太迟了。到了EJB3规范发布时，其他基于POJO的开发架构已经成为事实的标准了，而Spring框架也是在这样的大环境下出现的。
** Spring设计的初衷
   Spring是为解决企业级应用开发的复杂性而设计，她可以做很多事。但归根到底支撑Spring的仅仅是少许的基本理念，而所有地这些的基本理念都能可以追溯到一个最根本的使命：简化开发。这是一个郑重的承诺，其实许多框架都声称在某些方面做了简化。
   而Spring则立志于全方面的简化Java开发。对此，她主要采取了4个关键策略：
  + 基于POJO的轻量级和最小侵入性编程；
  + 通过依赖注入和面向接口松耦合；
  + 基于切面和惯性进行声明式编程；
  + 通过切面和模板减少样板式代码；
  而他主要是通过：面向Bean、依赖注入以及面向切面这三种方式来达成的。
** BOP编程伊始
   Spring是面向Bean的编程（BeanOrientedProgramming,BOP），Bean在Spring中才是真正的主角。Bean在Spring中作用就像Object对OOP的意义一样，Spring中没有Bean也就没有Spring存在的意义。Spring提供了IOC容器通过配置文件或者注解的方式来管理对象之间的依赖关系。
   控制反转(其中最常见的方式叫做依赖注入（DependencyInjection，DI），还有一种方式叫“依赖查找”（DependencyLookup，DL），她在C++、Java、PHP以及.NET中都运用。在最早的Spring中是包含有依赖注入方法和依赖查询的，但因为依赖查询使用频率过低，不久就被Spring移除了，所以在Spring中控制反转也被称作依赖注入)，她的基本概念是：不创建对象，但是描述创建它们的方式。在代码中不直接与对象和服务连接，但在配置文件中描述哪一个组件需要哪一项服务。容器（在Spring框架中是IOC容器）负责将这些联系在一起。
   在典型的IOC场景中，容器创建了所有对象，并设置必要的属性将它们连接在一起，决定什么时间调用方法。
** 依赖注入的基本概念
   Spring设计的核心org.springframework.beans包（架构核心是org.springframework.core包），它的设计目标是与JavaBean组件一起使用。这个包通常不是由用户直接使用，而是由服务器将其用作其他多数功能的底层中介。下一个最高级抽象是BeanFactory接口，它是工厂设计模式的实现，允许通过名称创建和检索对象。BeanFactory也可以管理对象之间的关系。
   BeanFactory支持两个对象模型。
    + 单例：模型提供了具有特定名称的对象的共享实例，可以在查询时对其进行检索。Singleton是默认的也是最常用的对象模型。对于无状态服务对象很理想。
    + 原型：模型确保每次检索都会创建单独的对象。在每个用户都需要自己的对象时，原型模型最适合。
    Bean工厂的概念是Spring作为IOC容器的基础。IOC则将处理事情的责任从应用程序代码转移到框架。
** AOP编程理念
   面向切面编程，即AOP，是一种编程思想，它允许程序员对横切关注点或横切典型的职责分界线的行为（例如日志和事务管理）进行模块化。AOP的核心构造是方面（切面），它将那些影响多个类的行为封装到可重用的模块中。
   AOP和IOC是补充性的技术，它们都运用模块化方式解决企业应用程序开发中的复杂问题。在典型的面向对象开发方式中，可能要将日志记录语句放在所有方法和Java类中才能实现日志功能。在AOP方式中，可以反过来将日志服务模块化，并以声明的方式将它们应用到需要日志的组件上。当然，优势就是Java类不需要知道日志服务的存在，也不需要考虑相关的代码。所以，用SpringAOP编写的应用程序代码是松散耦合的。
   AOP的功能完全集成到了Spring事务管理、日志和其他各种特性的上下文中。
   AOP编程的常用场景有：Authentication权限认证、Logging日志、TransctionsManager事务、
   LazyLoading懒加载、ContextProcess上下文处理、ErrorHandler错误跟踪（异常捕获机制）、Cache缓存。
* spring配置信息进化
  + applicatinxmlappcontext
    + (T)xx.getbean(xx)
    + xx.getbea.(xx, T)
  + annotationappcontext
* ejb和spring
  + ejb = localbean(当前容器bean) + remotebean(远程rpc) = rmi + interface = dubbo、 springcloud
  + spring container = localbean
  + spring cloud = remotebean
  + spring 是阉割版的ejb
* spring源码分析
** 类加载的过程， 从配置文件到加载完成
** 类调用过程
** 模块详细介绍
* spring干了几件事
* springdoc
  +https://docs.spring.io/spring/docs/
* 读源码
** Spring源码版本命名规则
  + 首先看看某些常见软件的版本号：
    LinuxKernel:0.0.1,1.0.0,2.6.32,3.0.18...,若用X.Y.Z表示，则偶数Y表示稳定版本，奇数Y表示开发版本。
    Windows:Windows98,Windows2000,Windowsxp,Windows7...,最大的特点是杂乱无章，毫无规律。
    SSHClient:0.9.8。
    OpenStack:2014.1.3,2015.1.1.dev8。
    从上可以看出，不同的软件版本号风格各异，随着系统的规模越大，依赖的软件越多，如果这些软件没有遵循一套规范的命名风格，容易造成DependencyHell。所以当我们发布版本时，版本号的命名需要遵循某种规则，其中SemanticVersioning2.0.0定义了一套简单的规则及条件来约束版本号的配置和增长。本文根据SemanticVersionning2.0.0和SemanticVersioning3.0.0选择性的整理出版本号命名规则指南。
  + 版本号命名规则指南
    版本号的格式为X.Y.Z(又称Major.Minor.Patch)，递增的规则为：
      X 表示主版本号，当API的兼容性变化时，X需递增。
      Y 表示次版本号，当增加功能时(不影响API的兼容性)，Y需递增。
      Z 表示修订号，当做Bug修复时(不影响API的兼容性)，Z需递增。详细的规则如下：
      X,Y,Z必须为非负整数，且不得包含前导零，必须按数值递增，如1.9.0->1.10.0->1.11.0
      0.Y.Z的版本号表明软件处于初始开发阶段，意味着API可能不稳定；1.0.0表明版本已有稳定的API。
      当API的兼容性变化时，X必须递增，Y和Z同时设置为0；当新增功能(不影响API的兼容性)或者API被标记为Deprecated时，Y必须递增，同时Z设置为0；当进行bugfix时，Z必须递增。
      先行版本号(Pre-release)意味该版本不稳定，可能存在兼容性问题，其格式为：X.Y.Z.[a-c][正整数]，如1.0.0.a1，1.0.0.b99，1.0.0.c1000。
      开发版本号常用于CI-CD，格式为X.Y.Z.dev[正整数]，如1.0.1.dev4。
      版本号的排序规则为依次比较主版本号、次版本号和修订号的数值，如1.0.0<1.0.1<1.1.1
      <2.0.0；对于先行版本号和开发版本号，有：1.0.0.a100<1.0.0，2.1.0.dev3<2.1.0；当存在字母时，以ASCII的排序来比较，如1.0.0.a1<1.0.0.b1。
      注意：版本一经发布，不得修改其内容，任何修改必须在新版本发布！ 
  + 一些修饰的词
    Snapshot:版本代表不稳定、尚处于开发中的版本
    Alpha:内部版本
    Beta:测试版
    Demo:演示版
    Enhance:增强版
    Free:自由版
    FullVersion:完整版，即正式版
    LTS:长期维护版本
    Release:发行版
    RC:即将作为正式版发布
    Standard:标准版
    Ultimate:旗舰版
    Upgrade:升级版
  + Spring版本命名规则
    + Release版本则代表稳定的版本
    + GA版本则代表广泛可用的稳定版(GeneralAvailability)
    + M版本则代表里程碑版(M是Milestone的意思）具有一些全新的功能或是具有里程碑意义的版本。
    + RC版本即将作为正式版发布


* 啥是spring, 及spring中一些名词解释
  Spring是一个开源的轻量级JavaSE（Java标准版本）/JavaEE（Java企业版本）开发应用框架，其目的是用于简化企业级应用程序开发。应用程序是由一组相互协作的对象组成。而在传统应用程序开发中，一个完整的应用是由一组相互协作的对象组成。所以开发一个应用除了要开发业务逻辑之外，最多的是关注如何使这些对象协作来完成所需功能，而且要低耦合、高内聚。业务逻辑开发是不可避免的， 那如果有个框架出来帮我们来创建对象及管理这些对象之间的依赖关系。可能有人说了，比如“抽象工厂、工厂方法设计模式”不也可以帮我们创建对象，“生成器模式”帮我们处理对象间的依赖关系，不也能完成这些功能吗？可是这些又需要我们创建另一些工厂类、生成器类，我们又要而外管理这些类，增加了我们的负担，如果能有种通过配置方式来创建对象，管理对象之间依赖关系，我们不需要通过工厂和生成器来创建及管理对象之间的依赖关系，这样我们是不是减少了许多工作，加速了开发，能节省出很多时间来干其他事。Spring框架刚出来时主要就是来完成这个功能。
  
  Spring框架除了帮我们管理对象及其依赖关系，还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，还能帮我管理最头疼的数据库事务，本身提供了一套简单的JDBC访问实现， 提供与第三方数据访问框架集成（如Hibernate、JPA），与各种JavaEE技术整合（如JavaMail、任务调度等等），提供一套自己的web层框架SpringMVC、而且还能非常简单的与第三方Web框架集成。从这里我们可以认为Spring是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力，从而使我们可以更自由的选择到底使用什么技术进行开发。而且不管是JAVASE（C/S架构）应用程序还是JAVAEE（B/S架构）应用程序都可以使用这个平台进行开发。
** 从bean开始
   1996，Java还只是一个新兴的、初出茅庐的编程语言。人们之所以关注她仅仅是因为，可以使用
   Java的Applet来开发Web应用。但这些开发者很快就发现这个新兴的语言还能做更多的事情。与之前的所有语言不同，Java让模块化构建复杂的系统成为可能（当时的软件行业虽然在业务上突飞猛进，但当时开发用的是传统的面向过程开发思想，软件的开发效率一直踟蹰不前。伴随着业务复杂性的不断加深，开发也变得越发困难。其实，当时也是面向对象思想飞速发展的时期，她在80年代末被提出，成熟于90年代，现今大多数编程语言都是面向对象的，当然这是后话了）。他们为Applet而来，为组件化而留。这便是最早的Java。

   同样在这一年的12月，Sun公司发布了当时还名不见经传但后来人尽皆知的JavaBean1.00-A规范。早期的JavaBean规范针对于Java，她定义了软件组件模型。这个规范规定了一整套编码策略，使简单的Java对象不仅可以被重用，而且还可以轻松地构建更为复杂的应用。尽管JavaBean最初是为重用应用组件而设计的，但当时他们却是主要用作构建窗体控件，毕竟在PC时代那才是主流。但相比于当时正如日中天的Delphi、VB和C++，他看起来还是太简易了，以至于无法胜任任何"实际的"工作。
   尽管现实中有很多系统是基于EJB构建的，但EJB从来没有实现它最初的设想：简化开发。EJB的声明式编程模型的确简化了很多基础架构层面的开发，例如事务和安全；但另一方面EJB在部署描述符和配套代码实现等方面变得异常复杂。随着时间的推移，很多开发者对EJB已经不再抱有幻想，开始寻求更简洁的方法。
   现在Java组件开发理念重新回归正轨。新的编程技术AOP和DI的不断出现，他们为JavaBean提供了之前EJB才能拥有的强大功能。这些技术为POJO提供了类似EJB的声明式编程模型，而没有引入任何EJB的复杂性。当简单的JavaBean足以胜任时，人们便不愿编写笨重的EJB组件了。
   客观地讲，EJB的发展甚至促进了基于POJO的编程模型。引入新的理念，最新的EJB规范相比之前的规范有了前所未有的简化，但对很多开发者而言，这一切的一切都来得太迟了。到了EJB3规范发布时，其他基于POJO的开发架构已经成为事实的标准了，而Spring框架也是在这样的大环境下出现的。
** Spring设计的初衷
   Spring是为解决企业级应用开发的复杂性而设计，她可以做很多事。但归根到底支撑Spring的仅仅是少许的基本理念，而所有地这些的基本理念都能可以追溯到一个最根本的使命：简化开发。这是一个郑重的承诺，其实许多框架都声称在某些方面做了简化。
   而Spring则立志于全方面的简化Java开发。对此，她主要采取了4个关键策略：
  + 基于POJO的轻量级和最小侵入性编程；
  + 通过依赖注入和面向接口松耦合；
  + 基于切面和惯性进行声明式编程；
  + 通过切面和模板减少样板式代码；
  而他主要是通过：面向Bean、依赖注入以及面向切面这三种方式来达成的。
** BOP编程伊始
   Spring是面向Bean的编程（BeanOrientedProgramming,BOP），Bean在Spring中才是真正的主角。Bean在Spring中作用就像Object对OOP的意义一样，Spring中没有Bean也就没有Spring存在的意义。Spring提供了IOC容器通过配置文件或者注解的方式来管理对象之间的依赖关系。
   控制反转(其中最常见的方式叫做依赖注入（DependencyInjection，DI），还有一种方式叫“依赖查找”（DependencyLookup，DL），她在C++、Java、PHP以及.NET中都运用。在最早的Spring中是包含有依赖注入方法和依赖查询的，但因为依赖查询使用频率过低，不久就被Spring移除了，所以在Spring中控制反转也被称作依赖注入)，她的基本概念是：不创建对象，但是描述创建它们的方式。在代码中不直接与对象和服务连接，但在配置文件中描述哪一个组件需要哪一项服务。容器（在Spring框架中是IOC容器）负责将这些联系在一起。
   在典型的IOC场景中，容器创建了所有对象，并设置必要的属性将它们连接在一起，决定什么时间调用方法。
** 依赖注入的基本概念
   Spring设计的核心org.springframework.beans包（架构核心是org.springframework.core包），它的设计目标是与JavaBean组件一起使用。这个包通常不是由用户直接使用，而是由服务器将其用作其他多数功能的底层中介。下一个最高级抽象是BeanFactory接口，它是工厂设计模式的实现，允许通过名称创建和检索对象。BeanFactory也可以管理对象之间的关系。
   BeanFactory支持两个对象模型。
    + 单例：模型提供了具有特定名称的对象的共享实例，可以在查询时对其进行检索。Singleton是默认的也是最常用的对象模型。对于无状态服务对象很理想。
    + 原型：模型确保每次检索都会创建单独的对象。在每个用户都需要自己的对象时，原型模型最适合。
    Bean工厂的概念是Spring作为IOC容器的基础。IOC则将处理事情的责任从应用程序代码转移到框架。
** AOP编程理念
   面向切面编程，即AOP，是一种编程思想，它允许程序员对横切关注点或横切典型的职责分界线的行为（例如日志和事务管理）进行模块化。AOP的核心构造是方面（切面），它将那些影响多个类的行为封装到可重用的模块中。
   AOP和IOC是补充性的技术，它们都运用模块化方式解决企业应用程序开发中的复杂问题。在典型的面向对象开发方式中，可能要将日志记录语句放在所有方法和Java类中才能实现日志功能。在AOP方式中，可以反过来将日志服务模块化，并以声明的方式将它们应用到需要日志的组件上。当然，优势就是Java类不需要知道日志服务的存在，也不需要考虑相关的代码。所以，用SpringAOP编写的应用程序代码是松散耦合的。
   AOP的功能完全集成到了Spring事务管理、日志和其他各种特性的上下文中。
   AOP编程的常用场景有：Authentication权限认证、Logging日志、TransctionsManager事务、
   LazyLoading懒加载、ContextProcess上下文处理、ErrorHandler错误跟踪（异常捕获机制）、Cache缓存。
** 什么是IOC/DI？
   IOC(InversionofControl)控制反转：所谓控制反转，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们可配置的文件。DI(DependencyInjection)依赖注入：就是指对象是被动接受依赖类而不是自己主动去找，换句话说就是指对象不是从容器中查找它依赖的类，而是在容器实例化对象的时候主动将它依赖的类注入给它。先从我们自己设计这样一个视角来考虑：

   对象和对象关系怎么表示？
   可以用xml，properties文件等语义化配置文件表示。
   描述对象关系的文件存放在哪里？
   可能是classpath，filesystem，或者是URL网络资源，servletContext等。回到正题，有了配置文件，还需要对配置文件解析。
   不同的配置文件对对象的描述不一样，如标准的，自定义声明式的，如何统一？在内部需要有一个统一的关于对象的定义，所有外部的描述都必须转化成统一的描述定义。
   如何对不同的配置文件进行解析？需要对不同的配置文件语法，采用不同的解析器
* spring配置信息进化
  + applicatinxmlappcontext
    + (T)xx.getbean(xx)
    + xx.getbea.(xx, T)
  + annotationappcontext
* ejb和spring
  + ejb = localbean(当前容器bean) + remotebean(远程rpc) = rmi + interface = dubbo、 springcloud
  + spring container = localbean
  + spring cloud = remotebean
  + spring 是阉割版的ejb
* spring源码分析
** 类加载的过程， 从配置文件到加载完成
** 类调用过程
** 模块详细介绍
* spring干了几件事
* springdoc
  +https://docs.spring.io/spring/docs/
* 读源码
** Spring源码版本命名规则
  + 首先看看某些常见软件的版本号：
    LinuxKernel:0.0.1,1.0.0,2.6.32,3.0.18...,若用X.Y.Z表示，则偶数Y表示稳定版本，奇数Y表示开发版本。
    Windows:Windows98,Windows2000,Windowsxp,Windows7...,最大的特点是杂乱无章，毫无规律。
    SSHClient:0.9.8。
    OpenStack:2014.1.3,2015.1.1.dev8。
    从上可以看出，不同的软件版本号风格各异，随着系统的规模越大，依赖的软件越多，如果这些软件没有遵循一套规范的命名风格，容易造成DependencyHell。所以当我们发布版本时，版本号的命名需要遵循某种规则，其中SemanticVersioning2.0.0定义了一套简单的规则及条件来约束版本号的配置和增长。本文根据SemanticVersionning2.0.0和SemanticVersioning3.0.0选择性的整理出版本号命名规则指南。
  + 版本号命名规则指南
    版本号的格式为X.Y.Z(又称Major.Minor.Patch)，递增的规则为：
      X 表示主版本号，当API的兼容性变化时，X需递增。
      Y 表示次版本号，当增加功能时(不影响API的兼容性)，Y需递增。
      Z 表示修订号，当做Bug修复时(不影响API的兼容性)，Z需递增。详细的规则如下：
      X,Y,Z必须为非负整数，且不得包含前导零，必须按数值递增，如1.9.0->1.10.0->1.11.0
      0.Y.Z的版本号表明软件处于初始开发阶段，意味着API可能不稳定；1.0.0表明版本已有稳定的API。
      当API的兼容性变化时，X必须递增，Y和Z同时设置为0；当新增功能(不影响API的兼容性)或者API被标记为Deprecated时，Y必须递增，同时Z设置为0；当进行bugfix时，Z必须递增。
      先行版本号(Pre-release)意味该版本不稳定，可能存在兼容性问题，其格式为：X.Y.Z.[a-c][正整数]，如1.0.0.a1，1.0.0.b99，1.0.0.c1000。
      开发版本号常用于CI-CD，格式为X.Y.Z.dev[正整数]，如1.0.1.dev4。
      版本号的排序规则为依次比较主版本号、次版本号和修订号的数值，如1.0.0<1.0.1<1.1.1
      <2.0.0；对于先行版本号和开发版本号，有：1.0.0.a100<1.0.0，2.1.0.dev3<2.1.0；当存在字母时，以ASCII的排序来比较，如1.0.0.a1<1.0.0.b1。
      注意：版本一经发布，不得修改其内容，任何修改必须在新版本发布！ 
  + 一些修饰的词
    Snapshot:版本代表不稳定、尚处于开发中的版本
    Alpha:内部版本
    Beta:测试版
    Demo:演示版
    Enhance:增强版
    Free:自由版
    FullVersion:完整版，即正式版
    LTS:长期维护版本
    Release:发行版
    RC:即将作为正式版发布
    Standard:标准版
    Ultimate:旗舰版
    Upgrade:升级版
  + Spring版本命名规则
    + Release版本则代表稳定的版本
    + GA版本则代表广泛可用的稳定版(GeneralAvailability)
    + M版本则代表里程碑版(M是Milestone的意思）具有一些全新的功能或是具有里程碑意义的版本。
    + RC版本即将作为正式版发布

** 模块的组成和功能如下：
  + 核心容器：由spring-beans、spring-core、spring-context和spring-expression（SpringExpressionLanguage,SpEL）4个模块组成。
  spring-context模块构架于核心模块之上，他扩展了BeanFactory，为她添加了Bean生命周期控制、框架事件体系以及资源加载透明化等功能。此外该模块还提供了许多企业级支持，如邮件访问、远程访问、任务调度等，ApplicationContext是该模块的核心接口，她是BeanFactory的超类，与BeanFactory不同，ApplicationContext容器实例化后会自动对所有的单实例Bean进行实例化与依赖关系的装配，使之处于待用状态。
  spring-expression模块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也方便的可以调用对象方法、操作数组、集合等。它的语法类似于传统EL，但提供了额外的功能，最出色的要数函数调用和简单字符串的模板函数。这种语言的特性是基于Spring产品的需求而设计，他可以非常方便地同SpringIOC进行交互。
  + AOP和设备支持：由spring-aop、spring-aspects和spring-instrument3个模块组成。
    spring-aop是Spring的另一个核心模块，是AOP主要的实现模块。作为继OOP后，对程序员影响最大的编程思想之一，AOP极大地开拓了人们对于编程的思路。在Spring中，他是以JVM的动态代理技术为基础，然后设计出了一系列的AOP横切实现，比如前置通知、返回通知、异常通知等，同时，
    Pointcut接口来匹配切入点，可以使用现有的切入点来设计横切面，也可以扩展相关方法根据需求进行切入。
    spring-aspects模块集成自AspectJ框架，主要是为SpringAOP提供多种AOP实现方法。
    spring-instrument模块是基于JAVASE中的"java.lang.instrument"进行设计的，应该算是AOP的一个支援模块，主要作用是在JVM启用时，生成一个代理类，程序员通过代理类在运行时修改类的字节，从而改变一个类的功能，实现AOP的功能。在分类里，我把他分在了AOP模块下，在Spring官方文档里对这个地方也有点含糊不清，这里是纯个人观点。
  + 数据访问及集成：由spring-jdbc、spring-tx、spring-orm、spring-jms和spring-oxm5个模块组成。
    spring-jdbc模块是Spring提供的JDBC抽象框架的主要实现模块，用于简化SpringJDBC。主要是提供JDBC模板方式、关系数据库对象化方式、SimpleJdbc方式、事务管理来简化JDBC编程，主要实现类是JdbcTemplate、SimpleJdbcTemplate以及NamedParameterJdbcTemplate。
    
    spring-tx模块是SpringJDBC事务控制实现模块。使用Spring框架，它对事务做了很好的封装，通过它的AOP配置，可以灵活的配置在任何一层；但是在很多的需求和应用，直接使用JDBC事务控制还是有其优势的。其实，事务是以业务逻辑为基础的；一个完整的业务应该对应业务层里的一个方法；如果业务操作失败，则整个事务回滚；所以，事务控制是绝对应该放在业务层的；但是，持久层的设计则应该遵循一个很重要的原则：保证操作的原子性，即持久层里的每个方法都应该是不可以分割的。所以，在使用SpringJDBC事务控制时，应该注意其特殊性。
    spring-orm模块是ORM框架支持模块，主要集成Hibernate,JavaPersistenceAPI(JPA)和JavaDataObjects(JDO)用于资源管理、数据访问对象(DAO)的实现和事务策略。
    
    spring-jms模块（JavaMessagingService）能够发送和接受信息，自SpringFramework4.1以后，他还提供了对spring-messaging模块的支撑。
    spring-oxm模块主要提供一个抽象层以支撑OXM（OXM是Object-to-XML-Mapping的缩写，它是一个O/M-mapper，将java对象映射成XML数据，或者将XML数据映射成java对象），例如：JAXB,Castor,XMLBeans,JiBX和XStream等。
  + Web：由spring-web、spring-webmvc、spring-websocket和spring-webflux4个模块组成。
    spring-web模块为Spring提供了最基础Web支持，主要建立于核心容器之上，通过Servlet或者Listeners来初始化IOC容器，也包含一些与Web相关的支持。
    spring-webmvc模块众所周知是一个的Web-Servlet模块，实现了Spring	MVC
    （model-view-Controller）的Web应用。
    spring-websocket模块主要是与Web前端的全双工通讯的协议。（资料缺乏，这是个人理解）
    spring-webflux是一个新的非堵塞函数式ReactiveWeb框架，可以用来建立异步的，非阻塞，事件驱动的服务，并且扩展性非常好。
  + 报文发送：即spring-messaging模块。
    spring-messaging是从Spring4开始新加入的一个模块，主要职责是为Spring框架集成一些基础的报文传送应用。
  + Test：即spring-test模块。
    spring-test模块主要为测试提供支持的，毕竟在不需要发布（程序）到你的应用服务器或者连接到其他企业设施的情况下能够执行一些集成测试或者其他测试对于任何企业都是非常重要的。
** BeanFactory
    SpringBean的创建是典型的工厂模式，这一系列的Bean工厂，也即IOC容器为开发者管理对象间的依赖关系提供了很多便利和基础服务，在Spring中有许多的IOC容器的实现供用户选择和使用，其相互关系如下：
    [[file:spring涨姿势/1.png]]
    其中BeanFactory作为最顶层的一个接口类，它定义了IOC容器的基本功能规范，BeanFactory有三个子类：ListableBeanFactory、HierarchicalBeanFactory和AutowireCapableBeanFactory。但是从上图中我们可以发现最终的默认实现类是DefaultListableBeanFactory，他实现了所有的接口。那为何要定义这么多层次的接口呢？查阅这些接口的源码和说明发现，每个接口都有他使用的场合，它主要是为了区分在Spring内部在操作过程中对象的传递和转化过程中，对对象的数据访问所做的限制。例如ListableBeanFactory接口表示这些Bean是可列表的，而HierarchicalBeanFactory表示的是这些Bean是有继承关系的，也就是每个Bean有可能有父Bean。AutowireCapableBeanFactory

    接口定义Bean的自动装配规则。这四个接口共同定义了Bean的集合、Bean之间的关系、以及Bean行为.
    最基本的IOC容器接口BeanFactory
    #+BEGIN_SRC java 
      publicinterfaceBeanFactory{

      //对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，
      //如果需要得到工厂本身，需要转义
      StringFACTORY_BEAN_PREFIX="&";

      //根据bean的名字，获取在IOC容器中得到bean实例
      ObjectgetBean(Stringname)throwsBeansException;

      //根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。
      <T>TgetBean(Stringname,@NullableClass<T>requiredType)throwsBeansException;


      ObjectgetBean(Stringname,Object...args)throwsBeansException;
      <T>TgetBean(Class<T>requiredType)throwsBeansException;
      <T>TgetBean(Class<T>requiredType,Object...args)throwsBeansException;

      //提供对bean的检索，看看是否在IOC容器有这个名字的beanbooleancontainsBean(Stringname);

      //根据bean名字得到bean实例，并同时判断这个bean是不是单例
      booleanisSingleton(Stringname)throwsNoSuchBeanDefinitionException;booleanisPrototype(Stringname)throwsNoSuchBeanDefinitionException;
      booleanisTypeMatch(Stringname,ResolvableTypetypeToMatch)throwsNoSuchBeanDefinitionException;booleanisTypeMatch(Stringname,@NullableClass<?>typeToMatch)throwsNoSuchBeanDefinitionException;

      //得到bean实例的Class类型
      @Nullable
      Class<?>getType(Stringname)throwsNoSuchBeanDefinitionException;

      //得到bean的别名，如果根据别名检索，那么其原名也会被检索出来
      String[]getAliases(Stringname);

      }
    #+END_SRC
    在BeanFactory里只对IOC容器的基本行为作了定义，根本不关心你的Bean是如何定义怎样加载的。正如我们只关心工厂里得到什么的产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心。
    而要知道工厂是如何产生对象的，我们需要看具体的IOC容器实现，Spring提供了许多IOC容器的实现。比如XmlBeanFactory，ClasspathXmlApplicationContext等。其中XmlBeanFactory就是针对最基本的IOC容器的实现，这个IOC容器可以读取XML文件定义的BeanDefinition（XML文件中对bean的描述）,如果说XmlBeanFactory是容器中的屌丝，ApplicationContext应该算容器中的高帅富.
    ApplicationContext是Spring提供的一个高级的IOC容器，它除了能够提供IOC容器的基本功能外，还为用户提供了以下的附加服务。
    从ApplicationContext接口的实现，我们看出其特点：
      + 支持信息源，可以实现国际化。（实现MessageSource接口）
      + 访问资源。(实现ResourcePatternResolver接口，后面章节会讲到)
      + 支持应用事件。(实现ApplicationEventPublisher接口)
** BeanDefinition
    SpringIOC容器管理了我们定义的各种Bean对象及其相互的关系，Bean对象在Spring实现中是以BeanDefinition来描述的，其继承体系如下：
    [[file:spring涨姿势/2.png]]
    Bean的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean的解析主要就是对Spring配置文件的解析。这个解析过程主要通过下图中的类完成：
    [[file:spring涨姿势/3.png]]

** IOC容器的初始化
   IOC容器的初始化包括BeanDefinition的Resource定位、载入和注册这三个基本的过程。我们以ApplicationContext为例讲解，ApplicationContext系列容器也许是我们最熟悉的，因为Web项目中使用的XmlWebApplicationContext就属于这个继承体系，还有
   ClasspathXmlApplicationContext等，其继承体系如下图所示：
    [[file:spring涨姿势/4.png]]
    ApplicationContext允许上下文嵌套，通过保持父上下文可以维持一个上下文体系。对于Bean的查找可以在这个上下文体系中发生，首先检查当前上下文，其次是父上下文，逐级向上，这样为不同的Spring应用提供了一个共享的Bean定义环境。
    下面我们分别简单地演示一下两种IOC容器的创建过程:
    + XmlBeanFactory(屌丝IOC)的整个流程通过XmlBeanFactory的源码，我们可以发现:
      #+BEGIN_SRC java
        public class XmlBeanFactory extends DefaultListableBeanFactory {

          private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this);


          /**
          * Create a new XmlBeanFactory with the given resource,
          * which must be parsable using DOM.
          * @param resource XML resource to load bean definitions from
          * @throws BeansException in case of loading or parsing errors
          */
          public XmlBeanFactory(Resource resource) throws BeansException {
            this(resource, null);
          }

          /**
          * Create a new XmlBeanFactory with the given input stream,
          * which must be parsable using DOM.
          * @param resource XML resource to load bean definitions from
          * @param parentBeanFactory parent bean factory
          * @throws BeansException in case of loading or parsing errors
          */
          public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException {
            super(parentBeanFactory);
            this.reader.loadBeanDefinitions(resource);
          }

        }
      #+END_SRC
      参照源码，自己演示一遍，理解定位、载入、注册的全过程
      #+BEGIN_SRC java
        //根据Xml配置文件创建Resource资源对象，该对象中包含了BeanDefinition的信息
        ClassPathResource resource=new ClassPathResource("application-context.xml");
        //创建DefaultListableBeanFactory
        DefaultListableBeanFactory factory=new DefaultListableBeanFactory();
        //创建XmlBeanDefinitionReader读取器，用于载入BeanDefinition。
        //之所以需要BeanFactory作为参数，是因为会将读取的信息回调配置给factory
        XmlBeanDefinitionReader reader=new XmlBeanDefinitionReader(factory);
        //XmlBeanDefinitionReader执行载入BeanDefinition的方法，最后会完成Bean的载入和注册。
        //完成后Bean就成功的放置到IOC容器当中，以后我们就可以从中取得Bean来使用
        reader.loadBeanDefinitions(resource);
        https://github.com/microzhao/demo/blob/master/java-beans/src/main/java/com/lx/demo/javabeans/SpringBeanGetDemo.java 
      #+END_SRC
    + 高富帅ioc容器 FileSystemXmlApplicationContext
      #+BEGIN_SRC java
      public class FileSystemXmlApplicationContext extends AbstractXmlApplicationContext {

        public FileSystemXmlApplicationContext(String... configLocations) throws BeansException {
            this(configLocations, true, (ApplicationContext)null);
        }

        public FileSystemXmlApplicationContext(String[] configLocations, ApplicationContext parent) throws BeansException {
            this(configLocations, true, parent);
        }

        public FileSystemXmlApplicationContext(String[] configLocations, boolean refresh) throws BeansException {
            this(configLocations, refresh, (ApplicationContext)null);
        }

        public FileSystemXmlApplicationContext(String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException {
            super(parent);
            this.setConfigLocations(configLocations);
            if (refresh) {
                this.refresh();
            }

    }
      #+END_SRC
      初始化容器时候主要设置资源加载器和进行资源定位调用链
      + FileSystemXmlApplicationContext#super(parent)(设置加载器)
        + AbstractRefreshableConfigApplicationContext#setConfigLocations(configLocations)(设置bean资源文件路径)
          #+BEGIN_SRC java
            public abstract class AbstractRefreshableConfigApplicationContext extends AbstractRefreshableApplicationContext
                implements BeanNameAware, InitializingBean {
              /**
              * Any number of these characters are considered delimiters between
              * multiple context config paths in a single String value.
              * @see org.springframework.context.support.AbstractXmlApplicationContext#setConfigLocation
              * @see org.springframework.web.context.ContextLoader#CONFIG_LOCATION_PARAM
              * @see org.springframework.web.servlet.FrameworkServlet#setContextConfigLocation
              */
              String CONFIG_LOCATION_DELIMITERS = ",; \t\n";
              /**
              * Set the config locations for this application context in init-param style,
              * i.e. with distinct locations separated by commas, semicolons or whitespace.
              * <p>If not set, the implementation may use a default as appropriate.
              * 调用例子: ClasspathResource res = new ClasspathResource("a.xml,b.xml,......");
              */
              public void setConfigLocation(String location) {
                setConfigLocations(StringUtils.tokenizeToStringArray(location, CONFIG_LOCATION_DELIMITERS));
              }

              /**
              * Set the config locations for this application context.
              * <p>If not set, the implementation may use a default as appropriate.
              * 例: ClasspathResource res = new ClasspathResource(newString[]{"a.xml","b.xml",......});
              */
              public void setConfigLocations(@Nullable String... locations) {
                if (locations != null) {
                  Assert.noNullElements(locations, "Config locations must not be null");
                  this.configLocations = new String[locations.length];
                  for (int i = 0; i < locations.length; i++) {
                    this.configLocations[i] = resolvePath(locations[i]).trim();
                  }
                }
                else {
                  this.configLocations = null;
                }
              }
            }
          #+END_SRC
          + AbstractApplicationContext#refresh() 模板方法， 继承该类后可自定义实现具体的方法
            #+BEGIN_EXAMPLE
            SpringIOC容器对Bean定义资源的载入是从refresh()函数开始的，refresh()是一个模板方法，
            refresh()方法的作用是：在创建IOC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IOC容器。refresh的作用类似于对IOC容器的重启，在新建立好的容器中对容器进行初始化，对Bean定义资源进行载入
            refresh()方法主要为IOC容器Bean的生命周期管理提供条件，SpringIOC容器载入Bean定义资源文件从其子类容器的refreshBeanFactory()方法启动，所以整个refresh()中“ConfigurableListableBeanFactorybeanFactory=obtainFreshBeanFactory();”这句以后代码的都是注册容器的信息源和生命周期事件，载入过程就是从这句代码启动。
            #+END_EXAMPLE
            #+BEGIN_SRC java
            public abstract class AbstractApplicationContext extends DefaultResourceLoader
              implements ConfigurableApplicationContext { 
              @Override
              public void refresh() throws BeansException, IllegalStateException {
                synchronized (this.startupShutdownMonitor) {
                  // Prepare this context for refreshing.
                  //调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识
                  prepareRefresh();

                  // Tell the subclass to refresh the internal bean factory.
                  //告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从
                  //子类的refreshBeanFactory()方法启动 org.springframework.context.support.AbstractRefreshableApplicationContext#refreshBeanFactory
                  ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

                  // Prepare the bean factory for use in this context.
                  //为BeanFactory配置容器特性，例如类加载器、事件处理器等
                  prepareBeanFactory(beanFactory);

                  // Allows post-processing of the bean factory in context subclasses.
                  //为容器的某些子类指定特殊的BeanPost事件处理器
                  postProcessBeanFactory(beanFactory);

                  // Invoke factory processors registered as beans in the context.
                  //调用所有注册的BeanFactoryPostProcessor
                  invokeBeanFactoryPostProcessors(beanFactory);

                  // Register bean processors that intercept bean creation.
                  //为BeanFactory注册BeanPost事件处理器.
                  //BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件
                  registerBeanPostProcessors(beanFactory);

                  // Initialize message source for this context.
                  //初始化信息源，和国际化相关
                  initMessageSource();

                  // Initialize event multicaster for this context.
                  //初始化容器事件传播器.
                  initApplicationEventMulticaster();

                  // Initialize other special beans in specific context subclasses.
                  //调用子类的某些特殊Bean初始化方法
                  onRefresh();

                  // Check for listener beans and register them.
                  //为事件传播器注册事件监听器
                  registerListeners();

                  // Instantiate all remaining (non-lazy-init) singletons.
                  //初始化所有剩余的单例Bean
                  finishBeanFactoryInitialization(beanFactory);

                  // Last step: publish corresponding event.
                  //初始化容器的生命周期事件处理器，并发布容器的生命周期事件
                  finishRefresh();
                }
              }
            }
            #+END_SRC
            + obtainFreshBeanFactory() --> AbstractRefreshableApplicationContext#refreshBeanFactory (委派模式, 功能全部由子类实现)
              #+BEGIN_SRC java
             	/**
              * This implementation performs an actual refresh of this context's underlying
              * bean factory, shutting down the previous bean factory (if any) and
              * initializing a fresh bean factory for the next phase of the context's lifecycle.
              */
              @Override
              protected final void refreshBeanFactory() throws BeansException {
              //有容器 关闭工厂 销毁bean
                if (hasBeanFactory()) {
                  destroyBeans();
                  closeBeanFactory();
                }
                try {
                //创建ioc容器
                  DefaultListableBeanFactory beanFactory = createBeanFactory();
                  beanFactory.setSerializationId(getId());
                  //定制话容器
                  customizeBeanFactory(beanFactory);
                  //载入bean定义信息， 委派给子类实现
                  loadBeanDefinitions(beanFactory);
                  synchronized (this.beanFactoryMonitor) {
                    this.beanFactory = beanFactory;
                  }
                }
                catch (IOException ex) {
                  throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
                }
              } 
              #+END_SRC
              + loadBeanDefinitions(beanFactory) --> org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions(org.springframework.beans.factory.support.DefaultListableBeanFactory) 委派子类执行
                #+BEGIN_SRC java
                public abstract class AbstractXmlApplicationContext extends AbstractRefreshableConfigApplicationContext {
                      /**
                      * Loads the bean definitions via an XmlBeanDefinitionReader.
                      * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader
                      * @see #initBeanDefinitionReader
                      * @see #loadBeanDefinitions
                      */
                      @Override
                      protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
                        // Create a new XmlBeanDefinitionReader for the given BeanFactory.
                        //创建XmlBeanDefinitionReader，即创建Bean读取器，并通过回调设置到容器中去，容器使用该读取器读取Bean定义资源
                        XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);

                        // Configure the bean definition reader with this context's
                        // resource loading environment.
                        beanDefinitionReader.setEnvironment(this.getEnvironment());
                        //为Bean读取器设置Spring资源加载器，AbstractXmlApplicationContext的
                        //祖先父类AbstractApplicationContext继承DefaultResourceLoader，因此，容器本身也是一个资源加载器
                        beanDefinitionReader.setResourceLoader(this);
                        beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));

                        // Allow a subclass to provide custom initialization of the reader,
                        // then proceed with actually loading the bean definitions.
                        initBeanDefinitionReader(beanDefinitionReader);
                        // 真正开始加载bean
                        loadBeanDefinitions(beanDefinitionReader);
                      }

                      /**
                      * Load the bean definitions with the given XmlBeanDefinitionReader.
                      * <p>The lifecycle of the bean factory is handled by the {@link #refreshBeanFactory}
                      * method; hence this method is just supposed to load and/or register bean definitions.
                      * @param reader the XmlBeanDefinitionReader to use
                      * @throws BeansException in case of bean registration errors
                      * @throws IOException if the required XML document isn't found
                      * @see #refreshBeanFactory
                      * @see #getConfigLocations
                      * @see #getResources
                      * @see #getResourcePatternResolver
                      */
                      protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
                      //获取Bean定义资源的定位
                        Resource[] configResources = getConfigResources();
                        if (configResources != null) {
                        //XmlBean读取器调用其父类AbstractBeanDefinitionReader读取定位的Bean定义资源
                          reader.loadBeanDefinitions(configResources);
                        }
                        //如果子类中获取的Bean定义资源定位为空，则获取FileSystemXmlApplicationContext
                        //构造方法中setConfigLocations方法设置的资源
                        String[] configLocations = getConfigLocations();
                        if (configLocations != null) {
                        //XmlBean读取器调用其父类AbstractBeanDefinitionReader读取定位的Bean定义资源
                          reader.loadBeanDefinitions(configLocations);
                        }
                      }

                  }
                #+END_SRC
                + loadBeanDefinitions --> org.springframework.beans.factory.support.AbstractBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.Resource...)  委派
                  #+BEGIN_SRC java
                    public int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources) throws BeanDefinitionStoreException {
                    //获取在IOC容器初始化过程中设置的资源加载器
                      ResourceLoader resourceLoader = getResourceLoader();
                      if (resourceLoader == null) {
                        throw new BeanDefinitionStoreException(
                            "Cannot load bean definitions from location [" + location + "]: no ResourceLoader available");
                      }

                      if (resourceLoader instanceof ResourcePatternResolver) {
                        // Resource pattern matching available.
                        try {
                          //将指定位置的Bean定义资源文件解析为SpringIOC容器封装的资源
                          //加载多个指定位置的Bean定义资源文件
                          Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);
                          //委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能
                          int count = loadBeanDefinitions(resources);
                          if (actualResources != null) {
                            Collections.addAll(actualResources, resources);
                          }
                          if (logger.isTraceEnabled()) {
                            logger.trace("Loaded " + count + " bean definitions from location pattern [" + location + "]");
                          }
                          return count;
                        }
                        catch (IOException ex) {
                          throw new BeanDefinitionStoreException(
                              "Could not resolve bean definition resource pattern [" + location + "]", ex);
                        }
                      }
                      else {
                        // Can only load single resources by absolute URL.
                        //将指定位置的Bean定义资源文件解析为SpringIOC容器封装的资源
                        //加载单个指定位置的Bean定义资源文件
                        Resource resource = resourceLoader.getResource(location);
                        int count = loadBeanDefinitions(resource);
                        if (actualResources != null) {
                          actualResources.add(resource);
                        }
                        if (logger.isTraceEnabled()) {
                          logger.trace("Loaded " + count + " bean definitions from location [" + location + "]");
                        }
                        return count;
                      }
                    }

                  #+END_SRC
                  + resourceloader类关系图
                    [[file://spring涨姿势/6.png]] 
                    [[file://spring涨姿势/7.png]]
                  + getResource --> org.springframework.core.io.DefaultResourceLoader#getResource (待验证，FileSystemXmlApplicationContext最终使用的getResources方法)
                    #+BEGIN_SRC java
                   	@Override
                    public Resource getResource(String location) {
                      Assert.notNull(location, "Location must not be null");

                      for (ProtocolResolver protocolResolver : this.protocolResolvers) {
                        Resource resource = protocolResolver.resolve(location, this);
                        if (resource != null) {
                          return resource;
                        }
                      }
                      //如果是类路径的方式，那需要使用ClassPathResource来得到bean文件的资源对象
                      if (location.startsWith("/")) {
                        return getResourceByPath(location);
                      }
                      else if (location.startsWith(CLASSPATH_URL_PREFIX)) {
                        return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());
                      }
                      else {
                        try {
                          // Try to parse the location as a URL...
                          //如果是URL方式，使用UrlResource作为bean文件的资源对象
                          URL url = new URL(location);
                          return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url));
                        }
                        catch (MalformedURLException ex) {
                          // No URL -> resolve as resource path.
                          //如果既不是classpath标识，又不是URL标识的Resource定位，则调用
                          //容器本身的getResourceByPath方法获取Resource
                          return getResourceByPath(location);
                        }
                      }
                    } 
                    #+END_SRC
                  + loadBeanDefinitions -- > org.springframework.beans.factory.xml.XmlBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.support.EncodedResource) 委派
                    #+BEGIN_SRC java
                   	public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
                      ...
                      //将资源文件转为InputStream的IO流
                        InputStream inputStream = encodedResource.getResource().getInputStream();
                        try {
                        //从InputStream中得到XML的解析源
                          InputSource inputSource = new InputSource(inputStream);
                          if (encodedResource.getEncoding() != null) {
                            inputSource.setEncoding(encodedResource.getEncoding());
                          }
                          return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
                        }
                        finally {
                          inputStream.close();
                        }
                      ...
                    } 
                    protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
                        throws BeanDefinitionStoreException {
                        //将XML文件转换为DOM对象，解析过程由documentLoader实现
                        Document doc = doLoadDocument(inputSource, resource);
                        //这里是启动对Bean定义解析的详细过程，该解析过程会用到Spring的Bean配置规则
                        int count = registerBeanDefinitions(doc, resource);
                        return count;
                    }
                    #+END_SRC
                    + doLoadDocument --> org.springframework.beans.factory.xml.DefaultDocumentLoader#loadDocument bean定义文件转换为document
                      #+BEGIN_SRC java
                      	/**
                          * Load the {@link Document} at the supplied {@link InputSource} using the standard JAXP-configured
                          * XML parser.
                          */
                          @Override
                          public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,
                              ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception {

                              //文档解析工厂
                            DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);
                            if (logger.isTraceEnabled()) {
                              logger.trace("Using JAXP provider [" + factory.getClass().getName() + "]");
                            }
                            //文档解析器
                            DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);
                            //解析文档
                            return builder.parse(inputSource);
                          }

                          /**
                          * Create the {@link DocumentBuilderFactory} instance.
                          * @param validationMode the type of validation: {@link XmlValidationModeDetector#VALIDATION_DTD DTD}
                          * or {@link XmlValidationModeDetector#VALIDATION_XSD XSD})
                          * @param namespaceAware whether the returned factory is to provide support for XML namespaces
                          * @return the JAXP DocumentBuilderFactory
                          * @throws ParserConfigurationException if we failed to build a proper DocumentBuilderFactory
                          */
                          protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware)
                              throws ParserConfigurationException {

                            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
                            factory.setNamespaceAware(namespaceAware);

                            //解析xml校验
                            if (validationMode != XmlValidationModeDetector.VALIDATION_NONE) {
                              factory.setValidating(true);
                              if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) {
                                // Enforce namespace aware for XSD...
                                factory.setNamespaceAware(true);
                                try {
                                  factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);
                                }
                                catch (IllegalArgumentException ex) {
                                  ParserConfigurationException pcex = new ParserConfigurationException(
                                      "Unable to validate using XSD: Your JAXP provider [" + factory +
                                      "] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? " +
                                      "Upgrade to Apache Xerces (or Java 1.5) for full XSD support.");
                                  pcex.initCause(ex);
                                  throw pcex;
                                }
                              }
                            }

                            return factory;
                          }

                          /**
                          * Create a JAXP DocumentBuilder that this bean definition reader
                          * will use for parsing XML documents. Can be overridden in subclasses,
                          * adding further initialization of the builder.
                          * @param factory the JAXP DocumentBuilderFactory that the DocumentBuilder
                          * should be created with
                          * @param entityResolver the SAX EntityResolver to use
                          * @param errorHandler the SAX ErrorHandler to use
                          * @return the JAXP DocumentBuilder
                          * @throws ParserConfigurationException if thrown by JAXP methods
                          */
                          protected DocumentBuilder createDocumentBuilder(DocumentBuilderFactory factory,
                              @Nullable EntityResolver entityResolver, @Nullable ErrorHandler errorHandler)
                              throws ParserConfigurationException {

                            DocumentBuilder docBuilder = factory.newDocumentBuilder();
                            if (entityResolver != null) {
                              docBuilder.setEntityResolver(entityResolver);
                            }
                            if (errorHandler != null) {
                              docBuilder.setErrorHandler(errorHandler);
                            }
                            return docBuilder;
                          }
                      #+END_SRC
                    + registerBeanDefinitions
                      #+BEGIN_SRC java
                      	public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
                        //得到BeanDefinitionDocumentReader来对xml格式的BeanDefinition解析
                          BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
                          //获得容器中注册的Bean数量
                          int countBefore = getRegistry().getBeanDefinitionCount();
                          //解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader只是个接口,
                          //具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成
                          documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
                          //统计解析的Bean数量
                          return getRegistry().getBeanDefinitionCount() - countBefore;
                        }
                      #+END_SRC
                      + registerBeanDefinitions --> org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions
                        #+BEGIN_SRC java
                       	/**
                        * Register each bean definition within the given root {@code <beans/>} element.
                        */
                        @SuppressWarnings("deprecation")  // for Environment.acceptsProfiles(String...)
                        protected void doRegisterBeanDefinitions(Element root) {
                        //具体的解析过程由BeanDefinitionParserDelegate实现, 该类中实现springxml的各种元素
                          BeanDefinitionParserDelegate parent = this.delegate;
                          this.delegate = createDelegate(getReaderContext(), root, parent);

                          if (this.delegate.isDefaultNamespace(root)) {
                            String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
                            if (StringUtils.hasText(profileSpec)) {
                              String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
                                  profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
                              // We cannot use Profiles.of(...) since profile expressions are not supported
                              // in XML config. See SPR-12458 for details.
                              if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
                                if (logger.isDebugEnabled()) {
                                  logger.debug("Skipped XML bean definition file due to specified profiles [" + profileSpec +
                                      "] not matching: " + getReaderContext().getResource());
                                }
                                return;
                              }
                            }
                          }

                          //自定义解析增强
                          preProcessXml(root);
                          parseBeanDefinitions(root, this.delegate);
                          //解析扩展
                          postProcessXml(root);

                          this.delegate = parent;
                        } 

                        protected BeanDefinitionParserDelegate createDelegate(
                            XmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate) {

                          BeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext);
                          //初始化根元素
                          delegate.initDefaults(root, parentDelegate);
                          return delegate;
                        }

                        /**
                        * Parse the elements at the root level in the document:
                        * "import", "alias", "bean".
                        * @param root the DOM root element of the document
                        */
                        protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
                        // spring 默认命名空间
                          if (delegate.isDefaultNamespace(root)) {
                            NodeList nl = root.getChildNodes();
                            for (int i = 0; i < nl.getLength(); i++) {
                              Node node = nl.item(i);
                              //xml元素节点
                              if (node instanceof Element) {
                                Element ele = (Element) node;
                                if (delegate.isDefaultNamespace(ele)) {
                                  parseDefaultElement(ele, delegate);
                                }
                                else {
                                // 不使用默认命名空间， 自定义解析规则
                                  delegate.parseCustomElement(ele);
                                }
                              }
                            }
                          }
                          else {
                            delegate.parseCustomElement(root);
                          }
                        }

                        private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
                        //导入
                          if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
                            importBeanDefinitionResource(ele);
                          }
                          //别名
                          else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
                            processAliasRegistration(ele);
                          }
                          // <bean
                          else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
                            processBeanDefinition(ele, delegate);
                          }
                          else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
                            // recurse
                            doRegisterBeanDefinitions(ele);
                          }
                        }

                        /**
                        * Parse an "import" element and load the bean definitions
                        * from the given resource into the bean factory.
                        */
                        protected void importBeanDefinitionResource(Element ele) {
                          String location = ele.getAttribute(RESOURCE_ATTRIBUTE);
                          if (!StringUtils.hasText(location)) {
                            getReaderContext().error("Resource location must not be empty", ele);
                            return;
                          }

                          // Resolve system properties: e.g. "${user.dir}"
                          location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);

                          Set<Resource> actualResources = new LinkedHashSet<>(4);

                          // Discover whether the location is an absolute or relative URI
                          boolean absoluteLocation = false;
                            absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();

                          // Absolute or relative?
                          if (absoluteLocation) {
                              int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);
                          }
                          else {
                            // No URL -> considering resource location as relative to the current file.
                              int importCount;
                              Resource relativeResource = getReaderContext().getResource().createRelative(location);
                              if (relativeResource.exists()) {
                                importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);
                                actualResources.add(relativeResource);
                              }
                              else {
                                String baseLocation = getReaderContext().getResource().getURL().toString();
                                importCount = getReaderContext().getReader().loadBeanDefinitions(
                                    StringUtils.applyRelativePath(baseLocation, location), actualResources);
                              }
                          }
                          Resource[] actResArray = actualResources.toArray(new Resource[0]);
                          getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));
                        }

                        /**
                        * Process the given alias element, registering the alias with the registry.
                        */
                        protected void processAliasRegistration(Element ele) {
                          String name = ele.getAttribute(NAME_ATTRIBUTE);
                          String alias = ele.getAttribute(ALIAS_ATTRIBUTE);
                          boolean valid = true;
                          if (!StringUtils.hasText(name)) {
                            getReaderContext().error("Name must not be empty", ele);
                            valid = false;
                          }
                          if (!StringUtils.hasText(alias)) {
                            getReaderContext().error("Alias must not be empty", ele);
                            valid = false;
                          }
                          if (valid) {
                              getReaderContext().getRegistry().registerAlias(name, alias);
                            getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));
                          }
                        }

                        /**
                        * Process the given bean element, parsing the bean definition
                        * and registering it with the registry.
                        */
                        protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
                        //封装beandefinition
                          BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
                          if (bdHolder != null) {
                            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
                              // Register the final decorated instance.
                              BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
                            // Send registration event.
                            getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
                          }
                        }
                        #+END_SRC

* 啥是spring, 及spring中一些名词解释
  Spring是一个开源的轻量级JavaSE（Java标准版本）/JavaEE（Java企业版本）开发应用框架，其目的是用于简化企业级应用程序开发。应用程序是由一组相互协作的对象组成。而在传统应用程序开发中，一个完整的应用是由一组相互协作的对象组成。所以开发一个应用除了要开发业务逻辑之外，最多的是关注如何使这些对象协作来完成所需功能，而且要低耦合、高内聚。业务逻辑开发是不可避免的， 那如果有个框架出来帮我们来创建对象及管理这些对象之间的依赖关系。可能有人说了，比如“抽象工厂、工厂方法设计模式”不也可以帮我们创建对象，“生成器模式”帮我们处理对象间的依赖关系，不也能完成这些功能吗？可是这些又需要我们创建另一些工厂类、生成器类，我们又要而外管理这些类，增加了我们的负担，如果能有种通过配置方式来创建对象，管理对象之间依赖关系，我们不需要通过工厂和生成器来创建及管理对象之间的依赖关系，这样我们是不是减少了许多工作，加速了开发，能节省出很多时间来干其他事。Spring框架刚出来时主要就是来完成这个功能。
  
  Spring框架除了帮我们管理对象及其依赖关系，还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，还能帮我管理最头疼的数据库事务，本身提供了一套简单的JDBC访问实现， 提供与第三方数据访问框架集成（如Hibernate、JPA），与各种JavaEE技术整合（如JavaMail、任务调度等等），提供一套自己的web层框架SpringMVC、而且还能非常简单的与第三方Web框架集成。从这里我们可以认为Spring是一个超级粘合平台，除了自己提供功能外，还提供粘合其他技术和框架的能力，从而使我们可以更自由的选择到底使用什么技术进行开发。而且不管是JAVASE（C/S架构）应用程序还是JAVAEE（B/S架构）应用程序都可以使用这个平台进行开发。
** 从bean开始
   1996，Java还只是一个新兴的、初出茅庐的编程语言。人们之所以关注她仅仅是因为，可以使用
   Java的Applet来开发Web应用。但这些开发者很快就发现这个新兴的语言还能做更多的事情。与之前的所有语言不同，Java让模块化构建复杂的系统成为可能（当时的软件行业虽然在业务上突飞猛进，但当时开发用的是传统的面向过程开发思想，软件的开发效率一直踟蹰不前。伴随着业务复杂性的不断加深，开发也变得越发困难。其实，当时也是面向对象思想飞速发展的时期，她在80年代末被提出，成熟于90年代，现今大多数编程语言都是面向对象的，当然这是后话了）。他们为Applet而来，为组件化而留。这便是最早的Java。

   同样在这一年的12月，Sun公司发布了当时还名不见经传但后来人尽皆知的JavaBean1.00-A规范。早期的JavaBean规范针对于Java，她定义了软件组件模型。这个规范规定了一整套编码策略，使简单的Java对象不仅可以被重用，而且还可以轻松地构建更为复杂的应用。尽管JavaBean最初是为重用应用组件而设计的，但当时他们却是主要用作构建窗体控件，毕竟在PC时代那才是主流。但相比于当时正如日中天的Delphi、VB和C++，他看起来还是太简易了，以至于无法胜任任何"实际的"工作。
   尽管现实中有很多系统是基于EJB构建的，但EJB从来没有实现它最初的设想：简化开发。EJB的声明式编程模型的确简化了很多基础架构层面的开发，例如事务和安全；但另一方面EJB在部署描述符和配套代码实现等方面变得异常复杂。随着时间的推移，很多开发者对EJB已经不再抱有幻想，开始寻求更简洁的方法。
   现在Java组件开发理念重新回归正轨。新的编程技术AOP和DI的不断出现，他们为JavaBean提供了之前EJB才能拥有的强大功能。这些技术为POJO提供了类似EJB的声明式编程模型，而没有引入任何EJB的复杂性。当简单的JavaBean足以胜任时，人们便不愿编写笨重的EJB组件了。
   客观地讲，EJB的发展甚至促进了基于POJO的编程模型。引入新的理念，最新的EJB规范相比之前的规范有了前所未有的简化，但对很多开发者而言，这一切的一切都来得太迟了。到了EJB3规范发布时，其他基于POJO的开发架构已经成为事实的标准了，而Spring框架也是在这样的大环境下出现的。
** Spring设计的初衷
   Spring是为解决企业级应用开发的复杂性而设计，她可以做很多事。但归根到底支撑Spring的仅仅是少许的基本理念，而所有地这些的基本理念都能可以追溯到一个最根本的使命：简化开发。这是一个郑重的承诺，其实许多框架都声称在某些方面做了简化。
   而Spring则立志于全方面的简化Java开发。对此，她主要采取了4个关键策略：
  + 基于POJO的轻量级和最小侵入性编程；
  + 通过依赖注入和面向接口松耦合；
  + 基于切面和惯性进行声明式编程；
  + 通过切面和模板减少样板式代码；
  而他主要是通过：面向Bean、依赖注入以及面向切面这三种方式来达成的。
** BOP编程伊始
   Spring是面向Bean的编程（BeanOrientedProgramming,BOP），Bean在Spring中才是真正的主角。Bean在Spring中作用就像Object对OOP的意义一样，Spring中没有Bean也就没有Spring存在的意义。Spring提供了IOC容器通过配置文件或者注解的方式来管理对象之间的依赖关系。
   控制反转(其中最常见的方式叫做依赖注入（DependencyInjection，DI），还有一种方式叫“依赖查找”（DependencyLookup，DL），她在C++、Java、PHP以及.NET中都运用。在最早的Spring中是包含有依赖注入方法和依赖查询的，但因为依赖查询使用频率过低，不久就被Spring移除了，所以在Spring中控制反转也被称作依赖注入)，她的基本概念是：不创建对象，但是描述创建它们的方式。在代码中不直接与对象和服务连接，但在配置文件中描述哪一个组件需要哪一项服务。容器（在Spring框架中是IOC容器）负责将这些联系在一起。
   在典型的IOC场景中，容器创建了所有对象，并设置必要的属性将它们连接在一起，决定什么时间调用方法。
** 依赖注入的基本概念
   Spring设计的核心org.springframework.beans包（架构核心是org.springframework.core包），它的设计目标是与JavaBean组件一起使用。这个包通常不是由用户直接使用，而是由服务器将其用作其他多数功能的底层中介。下一个最高级抽象是BeanFactory接口，它是工厂设计模式的实现，允许通过名称创建和检索对象。BeanFactory也可以管理对象之间的关系。
   BeanFactory支持两个对象模型。
    + 单例：模型提供了具有特定名称的对象的共享实例，可以在查询时对其进行检索。Singleton是默认的也是最常用的对象模型。对于无状态服务对象很理想。
    + 原型：模型确保每次检索都会创建单独的对象。在每个用户都需要自己的对象时，原型模型最适合。
    Bean工厂的概念是Spring作为IOC容器的基础。IOC则将处理事情的责任从应用程序代码转移到框架。
** AOP编程理念
   面向切面编程，即AOP，是一种编程思想，它允许程序员对横切关注点或横切典型的职责分界线的行为（例如日志和事务管理）进行模块化。AOP的核心构造是方面（切面），它将那些影响多个类的行为封装到可重用的模块中。
   AOP和IOC是补充性的技术，它们都运用模块化方式解决企业应用程序开发中的复杂问题。在典型的面向对象开发方式中，可能要将日志记录语句放在所有方法和Java类中才能实现日志功能。在AOP方式中，可以反过来将日志服务模块化，并以声明的方式将它们应用到需要日志的组件上。当然，优势就是Java类不需要知道日志服务的存在，也不需要考虑相关的代码。所以，用SpringAOP编写的应用程序代码是松散耦合的。
   AOP的功能完全集成到了Spring事务管理、日志和其他各种特性的上下文中。
   AOP编程的常用场景有：Authentication权限认证、Logging日志、TransctionsManager事务、
   LazyLoading懒加载、ContextProcess上下文处理、ErrorHandler错误跟踪（异常捕获机制）、Cache缓存。
** 什么是IOC/DI？
   IOC(InversionofControl)控制反转：所谓控制反转，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们可配置的文件。DI(DependencyInjection)依赖注入：就是指对象是被动接受依赖类而不是自己主动去找，换句话说就是指对象不是从容器中查找它依赖的类，而是在容器实例化对象的时候主动将它依赖的类注入给它。先从我们自己设计这样一个视角来考虑：

   对象和对象关系怎么表示？
   可以用xml，properties文件等语义化配置文件表示。
   描述对象关系的文件存放在哪里？
   可能是classpath，filesystem，或者是URL网络资源，servletContext等。回到正题，有了配置文件，还需要对配置文件解析。
   不同的配置文件对对象的描述不一样，如标准的，自定义声明式的，如何统一？在内部需要有一个统一的关于对象的定义，所有外部的描述都必须转化成统一的描述定义。
   如何对不同的配置文件进行解析？需要对不同的配置文件语法，采用不同的解析器
* spring配置信息进化
  + applicatinxmlappcontext
    + (T)xx.getbean(xx)
    + xx.getbea.(xx, T)
  + annotationappcontext
* ejb和spring
  + ejb = localbean(当前容器bean) + remotebean(远程rpc) = rmi + interface = dubbo、 springcloud
  + spring container = localbean
  + spring cloud = remotebean
  + spring 是阉割版的ejb
* spring源码分析
** 类加载的过程， 从配置文件到加载完成
** 类调用过程
** 模块详细介绍
* spring干了几件事
* springdoc
  +https://docs.spring.io/spring/docs/
* 读源码
** Spring源码版本命名规则
  + 首先看看某些常见软件的版本号：
    LinuxKernel:0.0.1,1.0.0,2.6.32,3.0.18...,若用X.Y.Z表示，则偶数Y表示稳定版本，奇数Y表示开发版本。
    Windows:Windows98,Windows2000,Windowsxp,Windows7...,最大的特点是杂乱无章，毫无规律。
    SSHClient:0.9.8。
    OpenStack:2014.1.3,2015.1.1.dev8。
    从上可以看出，不同的软件版本号风格各异，随着系统的规模越大，依赖的软件越多，如果这些软件没有遵循一套规范的命名风格，容易造成DependencyHell。所以当我们发布版本时，版本号的命名需要遵循某种规则，其中SemanticVersioning2.0.0定义了一套简单的规则及条件来约束版本号的配置和增长。本文根据SemanticVersionning2.0.0和SemanticVersioning3.0.0选择性的整理出版本号命名规则指南。
  + 版本号命名规则指南
    版本号的格式为X.Y.Z(又称Major.Minor.Patch)，递增的规则为：
      X 表示主版本号，当API的兼容性变化时，X需递增。
      Y 表示次版本号，当增加功能时(不影响API的兼容性)，Y需递增。
      Z 表示修订号，当做Bug修复时(不影响API的兼容性)，Z需递增。详细的规则如下：
      X,Y,Z必须为非负整数，且不得包含前导零，必须按数值递增，如1.9.0->1.10.0->1.11.0
      0.Y.Z的版本号表明软件处于初始开发阶段，意味着API可能不稳定；1.0.0表明版本已有稳定的API。
      当API的兼容性变化时，X必须递增，Y和Z同时设置为0；当新增功能(不影响API的兼容性)或者API被标记为Deprecated时，Y必须递增，同时Z设置为0；当进行bugfix时，Z必须递增。
      先行版本号(Pre-release)意味该版本不稳定，可能存在兼容性问题，其格式为：X.Y.Z.[a-c][正整数]，如1.0.0.a1，1.0.0.b99，1.0.0.c1000。
      开发版本号常用于CI-CD，格式为X.Y.Z.dev[正整数]，如1.0.1.dev4。
      版本号的排序规则为依次比较主版本号、次版本号和修订号的数值，如1.0.0<1.0.1<1.1.1
      <2.0.0；对于先行版本号和开发版本号，有：1.0.0.a100<1.0.0，2.1.0.dev3<2.1.0；当存在字母时，以ASCII的排序来比较，如1.0.0.a1<1.0.0.b1。
      注意：版本一经发布，不得修改其内容，任何修改必须在新版本发布！ 
  + 一些修饰的词
    Snapshot:版本代表不稳定、尚处于开发中的版本
    Alpha:内部版本
    Beta:测试版
    Demo:演示版
    Enhance:增强版
    Free:自由版
    FullVersion:完整版，即正式版
    LTS:长期维护版本
    Release:发行版
    RC:即将作为正式版发布
    Standard:标准版
    Ultimate:旗舰版
    Upgrade:升级版
  + Spring版本命名规则
    + Release版本则代表稳定的版本
    + GA版本则代表广泛可用的稳定版(GeneralAvailability)
    + M版本则代表里程碑版(M是Milestone的意思）具有一些全新的功能或是具有里程碑意义的版本。
    + RC版本即将作为正式版发布

** 模块的组成和功能如下：
  + 核心容器：由spring-beans、spring-core、spring-context和spring-expression（SpringExpressionLanguage,SpEL）4个模块组成。
  spring-context模块构架于核心模块之上，他扩展了BeanFactory，为她添加了Bean生命周期控制、框架事件体系以及资源加载透明化等功能。此外该模块还提供了许多企业级支持，如邮件访问、远程访问、任务调度等，ApplicationContext是该模块的核心接口，她是BeanFactory的超类，与BeanFactory不同，ApplicationContext容器实例化后会自动对所有的单实例Bean进行实例化与依赖关系的装配，使之处于待用状态。
  spring-expression模块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也方便的可以调用对象方法、操作数组、集合等。它的语法类似于传统EL，但提供了额外的功能，最出色的要数函数调用和简单字符串的模板函数。这种语言的特性是基于Spring产品的需求而设计，他可以非常方便地同SpringIOC进行交互。
  + AOP和设备支持：由spring-aop、spring-aspects和spring-instrument3个模块组成。
    spring-aop是Spring的另一个核心模块，是AOP主要的实现模块。作为继OOP后，对程序员影响最大的编程思想之一，AOP极大地开拓了人们对于编程的思路。在Spring中，他是以JVM的动态代理技术为基础，然后设计出了一系列的AOP横切实现，比如前置通知、返回通知、异常通知等，同时，
    Pointcut接口来匹配切入点，可以使用现有的切入点来设计横切面，也可以扩展相关方法根据需求进行切入。
    spring-aspects模块集成自AspectJ框架，主要是为SpringAOP提供多种AOP实现方法。
    spring-instrument模块是基于JAVASE中的"java.lang.instrument"进行设计的，应该算是AOP的一个支援模块，主要作用是在JVM启用时，生成一个代理类，程序员通过代理类在运行时修改类的字节，从而改变一个类的功能，实现AOP的功能。在分类里，我把他分在了AOP模块下，在Spring官方文档里对这个地方也有点含糊不清，这里是纯个人观点。
  + 数据访问及集成：由spring-jdbc、spring-tx、spring-orm、spring-jms和spring-oxm5个模块组成。
    spring-jdbc模块是Spring提供的JDBC抽象框架的主要实现模块，用于简化SpringJDBC。主要是提供JDBC模板方式、关系数据库对象化方式、SimpleJdbc方式、事务管理来简化JDBC编程，主要实现类是JdbcTemplate、SimpleJdbcTemplate以及NamedParameterJdbcTemplate。
    
    spring-tx模块是SpringJDBC事务控制实现模块。使用Spring框架，它对事务做了很好的封装，通过它的AOP配置，可以灵活的配置在任何一层；但是在很多的需求和应用，直接使用JDBC事务控制还是有其优势的。其实，事务是以业务逻辑为基础的；一个完整的业务应该对应业务层里的一个方法；如果业务操作失败，则整个事务回滚；所以，事务控制是绝对应该放在业务层的；但是，持久层的设计则应该遵循一个很重要的原则：保证操作的原子性，即持久层里的每个方法都应该是不可以分割的。所以，在使用SpringJDBC事务控制时，应该注意其特殊性。
    spring-orm模块是ORM框架支持模块，主要集成Hibernate,JavaPersistenceAPI(JPA)和JavaDataObjects(JDO)用于资源管理、数据访问对象(DAO)的实现和事务策略。
    
    spring-jms模块（JavaMessagingService）能够发送和接受信息，自SpringFramework4.1以后，他还提供了对spring-messaging模块的支撑。
    spring-oxm模块主要提供一个抽象层以支撑OXM（OXM是Object-to-XML-Mapping的缩写，它是一个O/M-mapper，将java对象映射成XML数据，或者将XML数据映射成java对象），例如：JAXB,Castor,XMLBeans,JiBX和XStream等。
  + Web：由spring-web、spring-webmvc、spring-websocket和spring-webflux4个模块组成。
    spring-web模块为Spring提供了最基础Web支持，主要建立于核心容器之上，通过Servlet或者Listeners来初始化IOC容器，也包含一些与Web相关的支持。
    spring-webmvc模块众所周知是一个的Web-Servlet模块，实现了Spring	MVC
    （model-view-Controller）的Web应用。
    spring-websocket模块主要是与Web前端的全双工通讯的协议。（资料缺乏，这是个人理解）
    spring-webflux是一个新的非堵塞函数式ReactiveWeb框架，可以用来建立异步的，非阻塞，事件驱动的服务，并且扩展性非常好。
  + 报文发送：即spring-messaging模块。
    spring-messaging是从Spring4开始新加入的一个模块，主要职责是为Spring框架集成一些基础的报文传送应用。
  + Test：即spring-test模块。
    spring-test模块主要为测试提供支持的，毕竟在不需要发布（程序）到你的应用服务器或者连接到其他企业设施的情况下能够执行一些集成测试或者其他测试对于任何企业都是非常重要的。
** BeanFactory
    SpringBean的创建是典型的工厂模式，这一系列的Bean工厂，也即IOC容器为开发者管理对象间的依赖关系提供了很多便利和基础服务，在Spring中有许多的IOC容器的实现供用户选择和使用，其相互关系如下：
    [[file:spring涨姿势/1.png]]
    其中BeanFactory作为最顶层的一个接口类，它定义了IOC容器的基本功能规范，BeanFactory有三个子类：ListableBeanFactory、HierarchicalBeanFactory和AutowireCapableBeanFactory。但是从上图中我们可以发现最终的默认实现类是DefaultListableBeanFactory，他实现了所有的接口。那为何要定义这么多层次的接口呢？查阅这些接口的源码和说明发现，每个接口都有他使用的场合，它主要是为了区分在Spring内部在操作过程中对象的传递和转化过程中，对对象的数据访问所做的限制。例如ListableBeanFactory接口表示这些Bean是可列表的，而HierarchicalBeanFactory表示的是这些Bean是有继承关系的，也就是每个Bean有可能有父Bean。AutowireCapableBeanFactory

    接口定义Bean的自动装配规则。这四个接口共同定义了Bean的集合、Bean之间的关系、以及Bean行为.
    最基本的IOC容器接口BeanFactory
    #+BEGIN_SRC java 
      publicinterfaceBeanFactory{

      //对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，
      //如果需要得到工厂本身，需要转义
      StringFACTORY_BEAN_PREFIX="&";

      //根据bean的名字，获取在IOC容器中得到bean实例
      ObjectgetBean(Stringname)throwsBeansException;

      //根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。
      <T>TgetBean(Stringname,@NullableClass<T>requiredType)throwsBeansException;


      ObjectgetBean(Stringname,Object...args)throwsBeansException;
      <T>TgetBean(Class<T>requiredType)throwsBeansException;
      <T>TgetBean(Class<T>requiredType,Object...args)throwsBeansException;

      //提供对bean的检索，看看是否在IOC容器有这个名字的beanbooleancontainsBean(Stringname);

      //根据bean名字得到bean实例，并同时判断这个bean是不是单例
      booleanisSingleton(Stringname)throwsNoSuchBeanDefinitionException;booleanisPrototype(Stringname)throwsNoSuchBeanDefinitionException;
      booleanisTypeMatch(Stringname,ResolvableTypetypeToMatch)throwsNoSuchBeanDefinitionException;booleanisTypeMatch(Stringname,@NullableClass<?>typeToMatch)throwsNoSuchBeanDefinitionException;

      //得到bean实例的Class类型
      @Nullable
      Class<?>getType(Stringname)throwsNoSuchBeanDefinitionException;

      //得到bean的别名，如果根据别名检索，那么其原名也会被检索出来
      String[]getAliases(Stringname);

      }
    #+END_SRC
    在BeanFactory里只对IOC容器的基本行为作了定义，根本不关心你的Bean是如何定义怎样加载的。正如我们只关心工厂里得到什么的产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心。
    而要知道工厂是如何产生对象的，我们需要看具体的IOC容器实现，Spring提供了许多IOC容器的实现。比如XmlBeanFactory，ClasspathXmlApplicationContext等。其中XmlBeanFactory就是针对最基本的IOC容器的实现，这个IOC容器可以读取XML文件定义的BeanDefinition（XML文件中对bean的描述）,如果说XmlBeanFactory是容器中的屌丝，ApplicationContext应该算容器中的高帅富.
    ApplicationContext是Spring提供的一个高级的IOC容器，它除了能够提供IOC容器的基本功能外，还为用户提供了以下的附加服务。
    从ApplicationContext接口的实现，我们看出其特点：
      + 支持信息源，可以实现国际化。（实现MessageSource接口）
      + 访问资源。(实现ResourcePatternResolver接口，后面章节会讲到)
      + 支持应用事件。(实现ApplicationEventPublisher接口)
** BeanDefinition
    SpringIOC容器管理了我们定义的各种Bean对象及其相互的关系，Bean对象在Spring实现中是以BeanDefinition来描述的，其继承体系如下：
    [[file:spring涨姿势/2.png]]
    Bean的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean的解析主要就是对Spring配置文件的解析。这个解析过程主要通过下图中的类完成：
    [[file:spring涨姿势/3.png]]

** IOC容器的初始化
   IOC容器的初始化包括BeanDefinition的Resource定位、载入和注册这三个基本的过程。我们以ApplicationContext为例讲解，ApplicationContext系列容器也许是我们最熟悉的，因为Web项目中使用的XmlWebApplicationContext就属于这个继承体系，还有
   ClasspathXmlApplicationContext等，其继承体系如下图所示：
    [[file:spring涨姿势/4.png]]
    ApplicationContext允许上下文嵌套，通过保持父上下文可以维持一个上下文体系。对于Bean的查找可以在这个上下文体系中发生，首先检查当前上下文，其次是父上下文，逐级向上，这样为不同的Spring应用提供了一个共享的Bean定义环境。
    下面我们分别简单地演示一下两种IOC容器的创建过程:
    + XmlBeanFactory(屌丝IOC)的整个流程通过XmlBeanFactory的源码，我们可以发现:
      #+BEGIN_SRC java
        public class XmlBeanFactory extends DefaultListableBeanFactory {

          private final XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(this);


          /**
          * Create a new XmlBeanFactory with the given resource,
          * which must be parsable using DOM.
          * @param resource XML resource to load bean definitions from
          * @throws BeansException in case of loading or parsing errors
          */
          public XmlBeanFactory(Resource resource) throws BeansException {
            this(resource, null);
          }

          /**
          * Create a new XmlBeanFactory with the given input stream,
          * which must be parsable using DOM.
          * @param resource XML resource to load bean definitions from
          * @param parentBeanFactory parent bean factory
          * @throws BeansException in case of loading or parsing errors
          */
          public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException {
            super(parentBeanFactory);
            this.reader.loadBeanDefinitions(resource);
          }

        }
      #+END_SRC
      参照源码，自己演示一遍，理解定位、载入、注册的全过程
      #+BEGIN_SRC java
        //根据Xml配置文件创建Resource资源对象，该对象中包含了BeanDefinition的信息
        ClassPathResource resource=new ClassPathResource("application-context.xml");
        //创建DefaultListableBeanFactory
        DefaultListableBeanFactory factory=new DefaultListableBeanFactory();
        //创建XmlBeanDefinitionReader读取器，用于载入BeanDefinition。
        //之所以需要BeanFactory作为参数，是因为会将读取的信息回调配置给factory
        XmlBeanDefinitionReader reader=new XmlBeanDefinitionReader(factory);
        //XmlBeanDefinitionReader执行载入BeanDefinition的方法，最后会完成Bean的载入和注册。
        //完成后Bean就成功的放置到IOC容器当中，以后我们就可以从中取得Bean来使用
        reader.loadBeanDefinitions(resource);
        https://github.com/microzhao/demo/blob/master/java-beans/src/main/java/com/lx/demo/javabeans/SpringBeanGetDemo.java 
      #+END_SRC
    + 高富帅ioc容器 FileSystemXmlApplicationContext
      #+BEGIN_SRC java
      public class FileSystemXmlApplicationContext extends AbstractXmlApplicationContext {

        public FileSystemXmlApplicationContext(String... configLocations) throws BeansException {
            this(configLocations, true, (ApplicationContext)null);
        }

        public FileSystemXmlApplicationContext(String[] configLocations, ApplicationContext parent) throws BeansException {
            this(configLocations, true, parent);
        }

        public FileSystemXmlApplicationContext(String[] configLocations, boolean refresh) throws BeansException {
            this(configLocations, refresh, (ApplicationContext)null);
        }

        public FileSystemXmlApplicationContext(String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException {
            super(parent);
            this.setConfigLocations(configLocations);
            if (refresh) {
                this.refresh();
            }

    }
      #+END_SRC
      初始化容器时候主要设置资源加载器和进行资源定位调用链
      + FileSystemXmlApplicationContext#super(parent)(设置加载器)
        + AbstractRefreshableConfigApplicationContext#setConfigLocations(configLocations)(设置bean资源文件路径)
          #+BEGIN_SRC java
            public abstract class AbstractRefreshableConfigApplicationContext extends AbstractRefreshableApplicationContext
                implements BeanNameAware, InitializingBean {
              /**
              * Any number of these characters are considered delimiters between
              * multiple context config paths in a single String value.
              * @see org.springframework.context.support.AbstractXmlApplicationContext#setConfigLocation
              * @see org.springframework.web.context.ContextLoader#CONFIG_LOCATION_PARAM
              * @see org.springframework.web.servlet.FrameworkServlet#setContextConfigLocation
              */
              String CONFIG_LOCATION_DELIMITERS = ",; \t\n";
              /**
              * Set the config locations for this application context in init-param style,
              * i.e. with distinct locations separated by commas, semicolons or whitespace.
              * <p>If not set, the implementation may use a default as appropriate.
              * 调用例子: ClasspathResource res = new ClasspathResource("a.xml,b.xml,......");
              */
              public void setConfigLocation(String location) {
                setConfigLocations(StringUtils.tokenizeToStringArray(location, CONFIG_LOCATION_DELIMITERS));
              }

              /**
              * Set the config locations for this application context.
              * <p>If not set, the implementation may use a default as appropriate.
              * 例: ClasspathResource res = new ClasspathResource(newString[]{"a.xml","b.xml",......});
              */
              public void setConfigLocations(@Nullable String... locations) {
                if (locations != null) {
                  Assert.noNullElements(locations, "Config locations must not be null");
                  this.configLocations = new String[locations.length];
                  for (int i = 0; i < locations.length; i++) {
                    this.configLocations[i] = resolvePath(locations[i]).trim();
                  }
                }
                else {
                  this.configLocations = null;
                }
              }
            }
          #+END_SRC
          + AbstractApplicationContext#refresh() 模板方法， 继承该类后可自定义实现具体的方法
            #+BEGIN_EXAMPLE
            SpringIOC容器对Bean定义资源的载入是从refresh()函数开始的，refresh()是一个模板方法，
            refresh()方法的作用是：在创建IOC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IOC容器。refresh的作用类似于对IOC容器的重启，在新建立好的容器中对容器进行初始化，对Bean定义资源进行载入
            refresh()方法主要为IOC容器Bean的生命周期管理提供条件，SpringIOC容器载入Bean定义资源文件从其子类容器的refreshBeanFactory()方法启动，所以整个refresh()中“ConfigurableListableBeanFactorybeanFactory=obtainFreshBeanFactory();”这句以后代码的都是注册容器的信息源和生命周期事件，载入过程就是从这句代码启动。
            #+END_EXAMPLE
            #+BEGIN_SRC java
            public abstract class AbstractApplicationContext extends DefaultResourceLoader
              implements ConfigurableApplicationContext { 
              @Override
              public void refresh() throws BeansException, IllegalStateException {
                synchronized (this.startupShutdownMonitor) {
                  // Prepare this context for refreshing.
                  //调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识
                  prepareRefresh();

                  // Tell the subclass to refresh the internal bean factory.
                  //告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从
                  //子类的refreshBeanFactory()方法启动 org.springframework.context.support.AbstractRefreshableApplicationContext#refreshBeanFactory
                  ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

                  // Prepare the bean factory for use in this context.
                  //为BeanFactory配置容器特性，例如类加载器、事件处理器等
                  prepareBeanFactory(beanFactory);

                  // Allows post-processing of the bean factory in context subclasses.
                  //为容器的某些子类指定特殊的BeanPost事件处理器
                  postProcessBeanFactory(beanFactory);

                  // Invoke factory processors registered as beans in the context.
                  //调用所有注册的BeanFactoryPostProcessor
                  invokeBeanFactoryPostProcessors(beanFactory);

                  // Register bean processors that intercept bean creation.
                  //为BeanFactory注册BeanPost事件处理器.
                  //BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件
                  registerBeanPostProcessors(beanFactory);

                  // Initialize message source for this context.
                  //初始化信息源，和国际化相关
                  initMessageSource();

                  // Initialize event multicaster for this context.
                  //初始化容器事件传播器.
                  initApplicationEventMulticaster();

                  // Initialize other special beans in specific context subclasses.
                  //调用子类的某些特殊Bean初始化方法
                  onRefresh();

                  // Check for listener beans and register them.
                  //为事件传播器注册事件监听器
                  registerListeners();

                  // Instantiate all remaining (non-lazy-init) singletons.
                  //初始化所有剩余的单例Bean
                  finishBeanFactoryInitialization(beanFactory);

                  // Last step: publish corresponding event.
                  //初始化容器的生命周期事件处理器，并发布容器的生命周期事件
                  finishRefresh();
                }
              }
            }
            #+END_SRC
            + obtainFreshBeanFactory() --> AbstractRefreshableApplicationContext#refreshBeanFactory (委派模式, 功能全部由子类实现)
              #+BEGIN_SRC java
             	/**
              * This implementation performs an actual refresh of this context's underlying
              * bean factory, shutting down the previous bean factory (if any) and
              * initializing a fresh bean factory for the next phase of the context's lifecycle.
              */
              @Override
              protected final void refreshBeanFactory() throws BeansException {
              //有容器 关闭工厂 销毁bean
                if (hasBeanFactory()) {
                  destroyBeans();
                  closeBeanFactory();
                }
                try {
                //创建ioc容器
                  DefaultListableBeanFactory beanFactory = createBeanFactory();
                  beanFactory.setSerializationId(getId());
                  //定制话容器
                  customizeBeanFactory(beanFactory);
                  //载入bean定义信息， 委派给子类实现
                  loadBeanDefinitions(beanFactory);
                  synchronized (this.beanFactoryMonitor) {
                    this.beanFactory = beanFactory;
                  }
                }
                catch (IOException ex) {
                  throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
                }
              } 
              #+END_SRC
              + loadBeanDefinitions(beanFactory) --> org.springframework.context.support.AbstractXmlApplicationContext#loadBeanDefinitions(org.springframework.beans.factory.support.DefaultListableBeanFactory) 委派子类执行
                #+BEGIN_SRC java
                public abstract class AbstractXmlApplicationContext extends AbstractRefreshableConfigApplicationContext {
                      /**
                      * Loads the bean definitions via an XmlBeanDefinitionReader.
                      * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader
                      * @see #initBeanDefinitionReader
                      * @see #loadBeanDefinitions
                      */
                      @Override
                      protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
                        // Create a new XmlBeanDefinitionReader for the given BeanFactory.
                        //创建XmlBeanDefinitionReader，即创建Bean读取器，并通过回调设置到容器中去，容器使用该读取器读取Bean定义资源
                        XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);

                        // Configure the bean definition reader with this context's
                        // resource loading environment.
                        beanDefinitionReader.setEnvironment(this.getEnvironment());
                        //为Bean读取器设置Spring资源加载器，AbstractXmlApplicationContext的
                        //祖先父类AbstractApplicationContext继承DefaultResourceLoader，因此，容器本身也是一个资源加载器
                        beanDefinitionReader.setResourceLoader(this);
                        beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));

                        // Allow a subclass to provide custom initialization of the reader,
                        // then proceed with actually loading the bean definitions.
                        initBeanDefinitionReader(beanDefinitionReader);
                        // 真正开始加载bean
                        loadBeanDefinitions(beanDefinitionReader);
                      }

                      /**
                      * Load the bean definitions with the given XmlBeanDefinitionReader.
                      * <p>The lifecycle of the bean factory is handled by the {@link #refreshBeanFactory}
                      * method; hence this method is just supposed to load and/or register bean definitions.
                      * @param reader the XmlBeanDefinitionReader to use
                      * @throws BeansException in case of bean registration errors
                      * @throws IOException if the required XML document isn't found
                      * @see #refreshBeanFactory
                      * @see #getConfigLocations
                      * @see #getResources
                      * @see #getResourcePatternResolver
                      */
                      protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
                      //获取Bean定义资源的定位
                        Resource[] configResources = getConfigResources();
                        if (configResources != null) {
                        //XmlBean读取器调用其父类AbstractBeanDefinitionReader读取定位的Bean定义资源
                          reader.loadBeanDefinitions(configResources);
                        }
                        //如果子类中获取的Bean定义资源定位为空，则获取FileSystemXmlApplicationContext
                        //构造方法中setConfigLocations方法设置的资源
                        String[] configLocations = getConfigLocations();
                        if (configLocations != null) {
                        //XmlBean读取器调用其父类AbstractBeanDefinitionReader读取定位的Bean定义资源
                          reader.loadBeanDefinitions(configLocations);
                        }
                      }

                  }
                #+END_SRC
                + loadBeanDefinitions --> org.springframework.beans.factory.support.AbstractBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.Resource...)  委派
                  #+BEGIN_SRC java
                    public int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources) throws BeanDefinitionStoreException {
                    //获取在IOC容器初始化过程中设置的资源加载器
                      ResourceLoader resourceLoader = getResourceLoader();
                      if (resourceLoader == null) {
                        throw new BeanDefinitionStoreException(
                            "Cannot load bean definitions from location [" + location + "]: no ResourceLoader available");
                      }

                      if (resourceLoader instanceof ResourcePatternResolver) {
                        // Resource pattern matching available.
                        try {
                          //将指定位置的Bean定义资源文件解析为SpringIOC容器封装的资源
                          //加载多个指定位置的Bean定义资源文件
                          Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);
                          //委派调用其子类XmlBeanDefinitionReader的方法，实现加载功能
                          int count = loadBeanDefinitions(resources);
                          if (actualResources != null) {
                            Collections.addAll(actualResources, resources);
                          }
                          if (logger.isTraceEnabled()) {
                            logger.trace("Loaded " + count + " bean definitions from location pattern [" + location + "]");
                          }
                          return count;
                        }
                        catch (IOException ex) {
                          throw new BeanDefinitionStoreException(
                              "Could not resolve bean definition resource pattern [" + location + "]", ex);
                        }
                      }
                      else {
                        // Can only load single resources by absolute URL.
                        //将指定位置的Bean定义资源文件解析为SpringIOC容器封装的资源
                        //加载单个指定位置的Bean定义资源文件
                        Resource resource = resourceLoader.getResource(location);
                        int count = loadBeanDefinitions(resource);
                        if (actualResources != null) {
                          actualResources.add(resource);
                        }
                        if (logger.isTraceEnabled()) {
                          logger.trace("Loaded " + count + " bean definitions from location [" + location + "]");
                        }
                        return count;
                      }
                    }

                  #+END_SRC
                  + resourceloader类关系图
                    [[file://spring涨姿势/6.png]] 
                    [[file://spring涨姿势/7.png]]
                  + getResource(定位) --> org.springframework.core.io.DefaultResourceLoader#getResource (待验证，FileSystemXmlApplicationContext最终使用的getResources方法)
                    #+BEGIN_SRC java
                   	@Override
                    public Resource getResource(String location) {
                      Assert.notNull(location, "Location must not be null");

                      for (ProtocolResolver protocolResolver : this.protocolResolvers) {
                        Resource resource = protocolResolver.resolve(location, this);
                        if (resource != null) {
                          return resource;
                        }
                      }
                      //如果是类路径的方式，那需要使用ClassPathResource来得到bean文件的资源对象
                      if (location.startsWith("/")) {
                        return getResourceByPath(location);
                      }
                      else if (location.startsWith(CLASSPATH_URL_PREFIX)) {
                        return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());
                      }
                      else {
                        try {
                          // Try to parse the location as a URL...
                          //如果是URL方式，使用UrlResource作为bean文件的资源对象
                          URL url = new URL(location);
                          return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url));
                        }
                        catch (MalformedURLException ex) {
                          // No URL -> resolve as resource path.
                          //如果既不是classpath标识，又不是URL标识的Resource定位，则调用
                          //容器本身的getResourceByPath方法获取Resource
                          return getResourceByPath(location);
                        }
                      }
                    } 
                    #+END_SRC
                  + loadBeanDefinitions -- > org.springframework.beans.factory.xml.XmlBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.support.EncodedResource) 委派
                    #+BEGIN_SRC java
                   	public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
                      ...
                      //将资源文件转为InputStream的IO流
                        InputStream inputStream = encodedResource.getResource().getInputStream();
                        try {
                        //从InputStream中得到XML的解析源
                          InputSource inputSource = new InputSource(inputStream);
                          if (encodedResource.getEncoding() != null) {
                            inputSource.setEncoding(encodedResource.getEncoding());
                          }
                          return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
                        }
                        finally {
                          inputStream.close();
                        }
                      ...
                    } 
                    protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
                        throws BeanDefinitionStoreException {
                        //将XML文件转换为DOM对象，解析过程由documentLoader实现
                        Document doc = doLoadDocument(inputSource, resource);
                        //这里是启动对Bean定义解析的详细过程，该解析过程会用到Spring的Bean配置规则
                        int count = registerBeanDefinitions(doc, resource);
                        return count;
                    }
                    #+END_SRC
                    + doLoadDocument --> org.springframework.beans.factory.xml.DefaultDocumentLoader#loadDocument bean定义文件转换为document
                      #+BEGIN_SRC java
                      	/**
                          * Load the {@link Document} at the supplied {@link InputSource} using the standard JAXP-configured
                          * XML parser.
                          */
                          @Override
                          public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,
                              ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception {

                              //文档解析工厂
                            DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);
                            if (logger.isTraceEnabled()) {
                              logger.trace("Using JAXP provider [" + factory.getClass().getName() + "]");
                            }
                            //文档解析器
                            DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);
                            //解析文档
                            return builder.parse(inputSource);
                          }

                          /**
                          * Create the {@link DocumentBuilderFactory} instance.
                          * @param validationMode the type of validation: {@link XmlValidationModeDetector#VALIDATION_DTD DTD}
                          * or {@link XmlValidationModeDetector#VALIDATION_XSD XSD})
                          * @param namespaceAware whether the returned factory is to provide support for XML namespaces
                          * @return the JAXP DocumentBuilderFactory
                          * @throws ParserConfigurationException if we failed to build a proper DocumentBuilderFactory
                          */
                          protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware)
                              throws ParserConfigurationException {

                            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
                            factory.setNamespaceAware(namespaceAware);

                            //解析xml校验
                            if (validationMode != XmlValidationModeDetector.VALIDATION_NONE) {
                              factory.setValidating(true);
                              if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) {
                                // Enforce namespace aware for XSD...
                                factory.setNamespaceAware(true);
                                try {
                                  factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);
                                }
                                catch (IllegalArgumentException ex) {
                                  ParserConfigurationException pcex = new ParserConfigurationException(
                                      "Unable to validate using XSD: Your JAXP provider [" + factory +
                                      "] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? " +
                                      "Upgrade to Apache Xerces (or Java 1.5) for full XSD support.");
                                  pcex.initCause(ex);
                                  throw pcex;
                                }
                              }
                            }

                            return factory;
                          }

                          /**
                          * Create a JAXP DocumentBuilder that this bean definition reader
                          * will use for parsing XML documents. Can be overridden in subclasses,
                          * adding further initialization of the builder.
                          * @param factory the JAXP DocumentBuilderFactory that the DocumentBuilder
                          * should be created with
                          * @param entityResolver the SAX EntityResolver to use
                          * @param errorHandler the SAX ErrorHandler to use
                          * @return the JAXP DocumentBuilder
                          * @throws ParserConfigurationException if thrown by JAXP methods
                          */
                          protected DocumentBuilder createDocumentBuilder(DocumentBuilderFactory factory,
                              @Nullable EntityResolver entityResolver, @Nullable ErrorHandler errorHandler)
                              throws ParserConfigurationException {

                            DocumentBuilder docBuilder = factory.newDocumentBuilder();
                            if (entityResolver != null) {
                              docBuilder.setEntityResolver(entityResolver);
                            }
                            if (errorHandler != null) {
                              docBuilder.setErrorHandler(errorHandler);
                            }
                            return docBuilder;
                          }
                      #+END_SRC
                    + registerBeanDefinitions(加载)
                      #+BEGIN_SRC java
                      	public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
                        //得到BeanDefinitionDocumentReader来对xml格式的BeanDefinition解析
                          BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
                          //获得容器中注册的Bean数量
                          int countBefore = getRegistry().getBeanDefinitionCount();
                          //解析过程入口，这里使用了委派模式，BeanDefinitionDocumentReader只是个接口,
                          //具体的解析实现过程有实现类DefaultBeanDefinitionDocumentReader完成
                          documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
                          //统计解析的Bean数量
                          return getRegistry().getBeanDefinitionCount() - countBefore;
                        }
                      #+END_SRC
                      + registerBeanDefinitions --> org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions
                        #+BEGIN_SRC java
                       	/**
                        * Register each bean definition within the given root {@code <beans/>} element.
                        */
                        @SuppressWarnings("deprecation")  // for Environment.acceptsProfiles(String...)
                        protected void doRegisterBeanDefinitions(Element root) {
                        //具体的解析过程由BeanDefinitionParserDelegate实现, 该类中实现springxml的各种元素
                          BeanDefinitionParserDelegate parent = this.delegate;
                          this.delegate = createDelegate(getReaderContext(), root, parent);

                          if (this.delegate.isDefaultNamespace(root)) {
                            String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
                            if (StringUtils.hasText(profileSpec)) {
                              String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
                                  profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
                              // We cannot use Profiles.of(...) since profile expressions are not supported
                              // in XML config. See SPR-12458 for details.
                              if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
                                if (logger.isDebugEnabled()) {
                                  logger.debug("Skipped XML bean definition file due to specified profiles [" + profileSpec +
                                      "] not matching: " + getReaderContext().getResource());
                                }
                                return;
                              }
                            }
                          }

                          //自定义解析增强
                          preProcessXml(root);
                          parseBeanDefinitions(root, this.delegate);
                          //解析扩展
                          postProcessXml(root);

                          this.delegate = parent;
                        } 

                        protected BeanDefinitionParserDelegate createDelegate(
                            XmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate) {

                          BeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext);
                          //初始化根元素
                          delegate.initDefaults(root, parentDelegate);
                          return delegate;
                        }

                        /**
                        * Parse the elements at the root level in the document:
                        * "import", "alias", "bean".
                        * @param root the DOM root element of the document
                        */
                        protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
                        // spring 默认命名空间
                          if (delegate.isDefaultNamespace(root)) {
                            NodeList nl = root.getChildNodes();
                            for (int i = 0; i < nl.getLength(); i++) {
                              Node node = nl.item(i);
                              //xml元素节点
                              if (node instanceof Element) {
                                Element ele = (Element) node;
                                if (delegate.isDefaultNamespace(ele)) {
                                  parseDefaultElement(ele, delegate);
                                }
                                else {
                                // 不使用默认命名空间， 自定义解析规则
                                  delegate.parseCustomElement(ele);
                                }
                              }
                            }
                          }
                          else {
                            delegate.parseCustomElement(root);
                          }
                        }

                        private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
                        //导入
                          if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
                            importBeanDefinitionResource(ele);
                          }
                          //别名
                          else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
                            processAliasRegistration(ele);
                          }
                          // <bean
                          else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
                            processBeanDefinition(ele, delegate);
                          }
                          else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
                            // recurse
                            doRegisterBeanDefinitions(ele);
                          }
                        }

                        /**
                        * Parse an "import" element and load the bean definitions
                        * from the given resource into the bean factory.
                        */
                        protected void importBeanDefinitionResource(Element ele) {
                          String location = ele.getAttribute(RESOURCE_ATTRIBUTE);
                          if (!StringUtils.hasText(location)) {
                            getReaderContext().error("Resource location must not be empty", ele);
                            return;
                          }

                          // Resolve system properties: e.g. "${user.dir}"
                          location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);

                          Set<Resource> actualResources = new LinkedHashSet<>(4);

                          // Discover whether the location is an absolute or relative URI
                          boolean absoluteLocation = false;
                            absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();

                          // Absolute or relative?
                          if (absoluteLocation) {
                              int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);
                          }
                          else {
                            // No URL -> considering resource location as relative to the current file.
                              int importCount;
                              Resource relativeResource = getReaderContext().getResource().createRelative(location);
                              if (relativeResource.exists()) {
                                importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);
                                actualResources.add(relativeResource);
                              }
                              else {
                                String baseLocation = getReaderContext().getResource().getURL().toString();
                                importCount = getReaderContext().getReader().loadBeanDefinitions(
                                    StringUtils.applyRelativePath(baseLocation, location), actualResources);
                              }
                          }
                          Resource[] actResArray = actualResources.toArray(new Resource[0]);
                          getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));
                        }

                        /**
                        * Process the given alias element, registering the alias with the registry.
                        */
                        protected void processAliasRegistration(Element ele) {
                          String name = ele.getAttribute(NAME_ATTRIBUTE);
                          String alias = ele.getAttribute(ALIAS_ATTRIBUTE);
                          boolean valid = true;
                          if (!StringUtils.hasText(name)) {
                            getReaderContext().error("Name must not be empty", ele);
                            valid = false;
                          }
                          if (!StringUtils.hasText(alias)) {
                            getReaderContext().error("Alias must not be empty", ele);
                            valid = false;
                          }
                          if (valid) {
                              getReaderContext().getRegistry().registerAlias(name, alias);
                            getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));
                          }
                        }

                        /**
                        * Process the given bean element, parsing the bean definition
                        * and registering it with the registry.
                        */
                        protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
                        //封装beandefinition
                          BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
                          if (bdHolder != null) {
                            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
                              // Register the final decorated instance.
                              //将解析好的bean注册到ioc容器中， 这个是入口
                              BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
                            // Send registration event.
                            getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
                          }
                        }
                        #+END_SRC
                        + processBeanDefinition --> org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseBeanDefinitionElement(org.w3c.dom.Element, org.springframework.beans.factory.config.BeanDefinition)
                            #+BEGIN_SRC java
                              @Nullable
                              public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
                                // <bean>元素中的id
                                String id = ele.getAttribute(ID_ATTRIBUTE);

                                // <bean>元素中的name
                                String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);

                                List<String> aliases = new ArrayList<>();
                                if (StringUtils.hasLength(nameAttr)) {
                                  String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
                                  aliases.addAll(Arrays.asList(nameArr));
                                }

                                //bean中没有配置id， 将第一个别名当bean唯一标识
                                String beanName = id;
                                if (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {
                                  beanName = aliases.remove(0);
                                }

                                //检测bean的唯一性
                                if (containingBean == null) {
                                  checkNameUniqueness(beanName, aliases, ele);
                                }
                                // 对bean进行详细解析
                                AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
                                if (beanDefinition != null) {
                                  if (!StringUtils.hasText(beanName)) {
                                      if (containingBean != null) {
                                        beanName = BeanDefinitionReaderUtils.generateBeanName(
                                            beanDefinition, this.readerContext.getRegistry(), true);
                                      }
                                      else {
                                        beanName = this.readerContext.generateBeanName(beanDefinition);
                                        // Register an alias for the plain bean class name, if still possible,
                                        // if the generator returned the class name plus a suffix.
                                        // This is expected for Spring 1.2/2.0 backwards compatibility.
                                        // 如果没有beanid 自动生存一个beanname来注册bean信息
                                        String beanClassName = beanDefinition.getBeanClassName();
                                        if (beanClassName != null &&
                                            beanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() &&
                                            !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
                                          aliases.add(beanClassName);
                                        }
                                      }
                                      if (logger.isTraceEnabled()) {
                                        logger.trace("Neither XML 'id' nor 'name' specified - " +
                                            "using generated bean name [" + beanName + "]");
                                      }
                                  }
                                  String[] aliasesArray = StringUtils.toStringArray(aliases);
                                  return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
                                }

                                return null;
                              } 

                              //主要对bean中其他属性进行解析， 前面已经对bean id， name做过解析
                              public AbstractBeanDefinition parseBeanDefinitionElement(
                                  Element ele, String beanName, @Nullable BeanDefinition containingBean) {

                                this.parseState.push(new BeanEntry(beanName));

                                //记录class名称不做实例话， 具体在注入时实例化
                                String className = null;
                                if (ele.hasAttribute(CLASS_ATTRIBUTE)) {
                                  className = ele.getAttribute(CLASS_ATTRIBUTE).trim();
                                }
                                String parent = null;
                                if (ele.hasAttribute(PARENT_ATTRIBUTE)) {
                                  parent = ele.getAttribute(PARENT_ATTRIBUTE);
                                }

                                try {
                                  // 创建bean定义信息，并设置bean的依赖关系等..
                                  AbstractBeanDefinition bd = createBeanDefinition(className, parent);

                                  parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
                                  bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));

                                  parseMetaElements(ele, bd);
                                  parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
                                  parseReplacedMethodSubElements(ele, bd.getMethodOverrides());

                                  parseConstructorArgElements(ele, bd);
                                  //<bean><property></property>></bean>
                                  parsePropertyElements(ele, bd);
                                  parseQualifierElements(ele, bd);

                                  //设置当前bean的所需资源和依赖对象
                                  bd.setResource(this.readerContext.getResource());
                                  bd.setSource(extractSource(ele));

                                  return bd;
                                }
                                finally {
                                  this.parseState.pop();
                                }

                                return null;
                              }
                            #+END_SRC
                          + parsePropertyElements
                            #+BEGIN_SRC java
                            // property属性解析
                            public void parsePropertyElements(Element beanEle, BeanDefinition bd) {
                              NodeList nl = beanEle.getChildNodes();
                              for (int i = 0; i < nl.getLength(); i++) {
                                Node node = nl.item(i);
                                //获取property子元素
                                if (isCandidateElement(node) && nodeNameEquals(node, PROPERTY_ELEMENT)) {
                                  parsePropertyElement((Element) node, bd);
                                }
                              }
                            }
                            public void parsePropertyElement(Element ele, BeanDefinition bd) {
                              String propertyName = ele.getAttribute(NAME_ATTRIBUTE);
                              if (!StringUtils.hasLength(propertyName)) {
                                error("Tag 'property' must have a 'name' attribute", ele);
                                return;
                              }
                              this.parseState.push(new PropertyEntry(propertyName));
                              try {
                                // 不能有同名property
                                if (bd.getPropertyValues().contains(propertyName)) {
                                  error("Multiple 'property' definitions for property '" + propertyName + "'", ele);
                                  return;
                                }
                                //Should only have one child element: ref, value, list, etc
                                Object val = parsePropertyValue(ele, bd, propertyName);
                                PropertyValue pv = new PropertyValue(propertyName, val);
                                //解析property中其他属性
                                parseMetaElements(ele, pv);
                                pv.setSource(extractSource(ele));
                                bd.getPropertyValues().addPropertyValue(pv);
                              }
                              finally {
                                this.parseState.pop();
                              }
                            }
                            #+END_SRC
                          + parsePropertyValue
                            #+BEGIN_SRC java
                              public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) {
                                String elementName = (propertyName != null ?
                                    "<property> element for property '" + propertyName + "'" :
                                    "<constructor-arg> element");

                                // Should only have one child element: ref, value, list, etc.
                                //解析property子元素
                                NodeList nl = ele.getChildNodes();
                                Element subElement = null;
                                for (int i = 0; i < nl.getLength(); i++) {
                                  Node node = nl.item(i);
                                  //子元素不是description和meta元素
                                  if (node instanceof Element && !nodeNameEquals(node, DESCRIPTION_ELEMENT) &&
                                      !nodeNameEquals(node, META_ELEMENT)) {
                                    // Child element is what we're looking for.
                                    if (subElement != null) {
                                      error(elementName + " must not contain more than one sub-element", ele);
                                    }
                                    else {
                                      subElement = (Element) node;
                                    }
                                  }
                                }

                                //属性值不能既是ref又是value
                                boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);
                                boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);
                                if ((hasRefAttribute && hasValueAttribute) ||
                                    ((hasRefAttribute || hasValueAttribute) && subElement != null)) {
                                  error(elementName +
                                      " is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element", ele);
                                }

                                if (hasRefAttribute) {
                                  String refName = ele.getAttribute(REF_ATTRIBUTE);
                                  if (!StringUtils.hasText(refName)) {
                                    error(elementName + " contains empty 'ref' attribute", ele);
                                  }
                                  RuntimeBeanReference ref = new RuntimeBeanReference(refName);
                                  ref.setSource(extractSource(ele));
                                  return ref;
                                }
                                else if (hasValueAttribute) {
                                //设置properties的引用关系
                                  TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));
                                  valueHolder.setSource(extractSource(ele));
                                  return valueHolder;
                                }
                                else if (subElement != null) {
                                //查找子元素
                                  return parsePropertySubElement(subElement, bd);
                                }
                                else {
                                  // Neither child element nor "ref" or "value" attribute found.
                                  error(elementName + " must specify a ref or value", ele);
                                  return null;
                                }
                              } 
                            #+END_SRC
                          + parsePropertySubElement(Element, BeanDefinition)
                            #+BEGIN_SRC java
                            	public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType) {
                              // 如果没有使用spring默认命名空间，就使用自定义
                                if (!isDefaultNamespace(ele)) {
                                  return parseNestedCustomElement(ele, bd);
                                }
                               //如果子元素是bean, 则解析bean 
                                else if (nodeNameEquals(ele, BEAN_ELEMENT)) {
                                  BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);
                                  if (nestedBd != null) {
                                    nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);
                                  }
                                  return nestedBd;
                                }
                                else if (nodeNameEquals(ele, REF_ELEMENT)) {
                                  // A generic reference to any name of any bean.
                                  String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);
                                  boolean toParent = false;
                                  if (!StringUtils.hasLength(refName)) {
                                    // A reference to the id of another bean in a parent context.
                                    refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);
                                    toParent = true;
                                    if (!StringUtils.hasLength(refName)) {
                                      error("'bean' or 'parent' is required for <ref> element", ele);
                                      return null;
                                    }
                                  }
                                  if (!StringUtils.hasText(refName)) {
                                    error("<ref> element contains empty target attribute", ele);
                                    return null;
                                  }
                                  RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);
                                  ref.setSource(extractSource(ele));
                                  return ref;
                                }
                                else if (nodeNameEquals(ele, IDREF_ELEMENT)) {
                                  return parseIdRefElement(ele);
                                }
                                else if (nodeNameEquals(ele, VALUE_ELEMENT)) {
                                  return parseValueElement(ele, defaultValueType);
                                }
                                else if (nodeNameEquals(ele, NULL_ELEMENT)) {
                                  // It's a distinguished null value. Let's wrap it in a TypedStringValue
                                  // object in order to preserve the source location.
                                  TypedStringValue nullHolder = new TypedStringValue(null);
                                  nullHolder.setSource(extractSource(ele));
                                  return nullHolder;
                                }
                                else if (nodeNameEquals(ele, ARRAY_ELEMENT)) {
                                  return parseArrayElement(ele, bd);
                                }
                                else if (nodeNameEquals(ele, LIST_ELEMENT)) {
                                  return parseListElement(ele, bd);
                                }
                                else if (nodeNameEquals(ele, SET_ELEMENT)) {
                                  return parseSetElement(ele, bd);
                                }
                                else if (nodeNameEquals(ele, MAP_ELEMENT)) {
                                  return parseMapElement(ele, bd);
                                }
                                else if (nodeNameEquals(ele, PROPS_ELEMENT)) {
                                  return parsePropsElement(ele);
                                }
                                else {
                                  error("Unknown property sub-element: [" + ele.getNodeName() + "]", ele);
                                  return null;
                                }
                              }
                            #+END_SRC
                          + parseListElement
                            #+BEGIN_SRC java
                            	public List<Object> parseListElement(Element collectionEle, @Nullable BeanDefinition bd) {
                              //获取集合元素数据类型
                                  String defaultElementType = collectionEle.getAttribute(VALUE_TYPE_ATTRIBUTE);
                                  //获取所有子节点
                                  NodeList nl = collectionEle.getChildNodes();
                                  //list 封装为managedlit
                                  ManagedList<Object> target = new ManagedList<>(nl.getLength());
                                  target.setSource(extractSource(collectionEle));
                                  //设置目标类型
                                  target.setElementTypeName(defaultElementType);
                                  target.setMergeEnabled(parseMergeAttribute(collectionEle));
                                  //具体解析过程
                                  parseCollectionElements(nl, target, bd, defaultElementType);
                                  return target;
                                }
                            #+END_SRC
                          + parseCollectionElements
                            #+BEGIN_SRC java
                           	protected void parseCollectionElements(
                                NodeList elementNodes, Collection<Object> target, @Nullable BeanDefinition bd, String defaultElementType) {

                              for (int i = 0; i < elementNodes.getLength(); i++) {
                                Node node = elementNodes.item(i);
                                if (node instanceof Element && !nodeNameEquals(node, DESCRIPTION_ELEMENT)) {
                                  target.add(parsePropertySubElement((Element) node, bd, defaultElementType));
                                }
                              }
                            } 
                            #+END_SRC
                        + registerBeanDefinition(注册) -->org.springframework.beans.factory.support.BeanDefinitionReaderUtils#registerBeanDefinition (bdHolder, getReaderContext().getRegistry());
                          #+BEGIN_SRC java
                          	public static void registerBeanDefinition(
                              BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
                              throws BeanDefinitionStoreException {

                              // Register bean definition under primary name.
                              // 获取解析的beandefinition名称
                              String beanName = definitionHolder.getBeanName();
                              //向 ioc容器中注册beandefination
                              registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

                              // Register aliases for bean name, if any.
                              // 如果beandefination有别名就注册别名
                              String[] aliases = definitionHolder.getAliases();
                              if (aliases != null) {
                                for (String alias : aliases) {
                                  registry.registerAlias(beanName, alias);
                                }
                              }
                            }
                          #+END_SRC
                          + registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()) --> org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition
                            #+BEGIN_SRC java

                              /** Map of bean definition objects, keyed by bean name. */
                              //这个就是真正的ioc容器
                              private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256); 

                            	@Override
                                public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
                                    throws BeanDefinitionStoreException {

                                  Assert.hasText(beanName, "Bean name must not be empty");
                                  Assert.notNull(beanDefinition, "BeanDefinition must not be null");

                                  if (beanDefinition instanceof AbstractBeanDefinition) {
                                    try {
                                      ((AbstractBeanDefinition) beanDefinition).validate();
                                    }
                                    catch (BeanDefinitionValidationException ex) {
                                      throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                                          "Validation of bean definition failed", ex);
                                    }
                                  }

                                  BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
                                  if (existingDefinition != null) {
                                    if (!isAllowBeanDefinitionOverriding()) {
                                      throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
                                    }
                                    else if (existingDefinition.getRole() < beanDefinition.getRole()) {
                                      // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
                                      if (logger.isInfoEnabled()) {
                                        logger.info("Overriding user-defined bean definition for bean '" + beanName +
                                            "' with a framework-generated bean definition: replacing [" +
                                            existingDefinition + "] with [" + beanDefinition + "]");
                                      }
                                    }
                                    else if (!beanDefinition.equals(existingDefinition)) {
                                      if (logger.isDebugEnabled()) {
                                        logger.debug("Overriding bean definition for bean '" + beanName +
                                            "' with a different definition: replacing [" + existingDefinition +
                                            "] with [" + beanDefinition + "]");
                                      }
                                    }
                                    else {
                                      if (logger.isTraceEnabled()) {
                                        logger.trace("Overriding bean definition for bean '" + beanName +
                                            "' with an equivalent definition: replacing [" + existingDefinition +
                                            "] with [" + beanDefinition + "]");
                                      }
                                    }
                                    this.beanDefinitionMap.put(beanName, beanDefinition);
                                  }
                                  else {
                                    if (hasBeanCreationStarted()) {
                                      // Cannot modify startup-time collection elements anymore (for stable iteration)
                                      //注册过程中通过线程同步保证数据一致性
                                      synchronized (this.beanDefinitionMap) {
                                        this.beanDefinitionMap.put(beanName, beanDefinition);
                                        List<String> updatedDefinitions = new ArrayList<>(this.beanDefinitionNames.size() + 1);
                                        updatedDefinitions.addAll(this.beanDefinitionNames);
                                        updatedDefinitions.add(beanName);
                                        this.beanDefinitionNames = updatedDefinitions;
                                        if (this.manualSingletonNames.contains(beanName)) {
                                          Set<String> updatedSingletons = new LinkedHashSet<>(this.manualSingletonNames);
                                          updatedSingletons.remove(beanName);
                                          this.manualSingletonNames = updatedSingletons;
                                        }
                                      }
                                    }
                                    else {
                                      // Still in startup registration phase
                                      this.beanDefinitionMap.put(beanName, beanDefinition);
                                      this.beanDefinitionNames.add(beanName);
                                      this.manualSingletonNames.remove(beanName);
                                    }
                                    this.frozenBeanDefinitionNames = null;
                                  }

                                  //检查同名bean是否注册过
                                  if (existingDefinition != null || containsSingleton(beanName)) {
                                  //注册过的重置
                                    resetBeanDefinition(beanName);
                                  }
                                }
                            #+END_SRC
      + 总结ioc容器加载过程
        1. 初始化的入口在容器实现中的refresh()调用来完成。        
        2. 对bean定义载入IOC容器使用的方法是loadBeanDefinition,        
           其中的大致过程如下：通过ResourceLoader来完成资源文件位置的定位，DefaultResourceLoader是默认的实现，同时上下文本身就给出了ResourceLoader的实现，可以从类路径，文件系统,URL等方式来定为资源位置。如果是XmlBeanFactory作为IOC容器，那么需要为它指定bean定义的资源，也就是说bean定义文件时通过抽象成Resource来被IOC容器处理的，容器通过        BeanDefinitionReader来完成定义信息的解析和Bean信息的注册,往往使用的是        XmlBeanDefinitionReader来解析bean的xml定义文件-实际的处理过程是委托给        BeanDefinitionParserDelegate来完成的，从而得到bean的定义信息，这些信息在Spring中使用        BeanDefinition对象来表示-这个名字可以让我们想到        loadBeanDefinition,RegisterBeanDefinition这些相关方法-他们都是为处理BeanDefinitin服        务的，容器解析得到BeanDefinition以后，需要把它在IOC容器中注册，这由IOC实现        BeanDefinitionRegistry接口来实现。注册过程就是在IOC容器内部维护的一个HashMap来保存得        到的BeanDefinition的过程。这个HashMap是IOC容器持有Bean信息的场所，以后对Bean的操作        都是围绕这个HashMap来实现的。        然后我们就可以通过BeanFactory和ApplicationContext来享受到SpringIOC的服务了,在使用        IOC容器的时候，我们注意到除了少量粘合代码，绝大多数以正确IOC风格编写的应用程序代码完全不        用关心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放        到已知的地方，最好是放在对预期使用的上下文有意义的地方，以及代码将实际需要访问工厂的地方。        Spring本身提供了对声明式载入web应用程序用法的应用程序上下文,并将其存储在ServletContext        中的框架实现。
      + beanfactory 和 factorybean
        BeanFactory和FactoryBean，其中BeanFactory指的是IOC容器的编程抽象，比如ApplicationContext，XmlBeanFactory等，这些都是IOC容器的具体表现，需要使用什么样的容器由客户决定,但Spring为我们提供了丰富的选择。FactoryBean只是一个可以在IOC而容器中被管理的一个Bean,是对各种处理过程和资源使用的抽象,FactoryBean在需要时产生另一个对象，而不返回FactoryBean本身,我们可以把它看成是一个抽象工厂，对它的调用返回的是工厂生产的产品。所有的FactoryBean都实现特殊的org.springframework.beans.factory.FactoryBean接口，当使用容器中FactoryBean的时候，该容器不会返回FactoryBean本身,而是返回其生成的对象。Spring包括了大部分的通用资源和服务访问抽象的FactoryBean的实现，其中包括:对JNDI查询的处理，对代理对象的处理，对事务性代理的处理，对RMI代理的处理等，这些我们都可以看成是具体的工厂,看成是Spring为我们建立好的工厂。也就是说Spring通过使用抽象工厂模式为我们准备了一系列工厂来生产一些特定的对象,免除我们手工重复的工作，我们要使用时只需要在IOC容器里配置好就能很方便的使用了。
** DI 依赖注入(基于xml依赖注入)
  + 依赖注入发生的时间
    当 Spring IOC 容器完成了 Bean 定义资源的定位、 载入和解析注册以后， IOC 容器中已经管理类 Bean定义的相关数据， 但是此时 IOC 容器还没有对所管理的 Bean 进行依赖注入， 依赖注入在以下两种情况发生：
    (1).用户第一次通过 getBean 方法向 IOC 容索要 Bean 时， IOC 容器触发依赖注入。
    (2).当用户在 Bean 定义资源中为<bean>元素配置了 lazy-init 属性，即让容器在解析注册 Bean 定义时进行预实例化， 触发依赖注入。BeanFactory 接口定义了 Spring IOC 容器的基本功能规范， 是 Spring IOC 容器所应遵守的最底层和最基本的编程规范。 BeanFactory 接口中定义了几个 getBean 方法， 就是用户向 IOC 容器索取管理的Bean 的方法， 我们通过分析其子类的具体实现， 理解 Spring IOC 容器在用户索取 Bean 时如何完成依赖注入
  + AbstractBeanFactory 通过 getBean 向 IOC 容器获取被管理的 Bean，
    #+BEGIN_SRC java
      @Override
      public Object getBean(String name) throws BeansException {
        return doGetBean(name, null, null, false);
      }

      @Override
      public <T> T getBean(String name, Class<T> requiredType) throws BeansException {
        return doGetBean(name, requiredType, null, false);
      }

      @Override
      public Object getBean(String name, Object... args) throws BeansException {
        return doGetBean(name, null, args, false);
      }

      /**
      * Return an instance, which may be shared or independent, of the specified bean.
      * @param name the name of the bean to retrieve
      * @param requiredType the required type of the bean to retrieve
      * @param args arguments to use when creating a bean instance using explicit arguments
      * (only applied when creating a new instance as opposed to retrieving an existing one)
      * @return an instance of the bean
      * @throws BeansException if the bean could not be created
      */
      public <T> T getBean(String name, @Nullable Class<T> requiredType, @Nullable Object... args)
          throws BeansException {

        return doGetBean(name, requiredType, args, false);
      }

      /**
      * Return an instance, which may be shared or independent, of the specified bean.
      * @param name the name of the bean to retrieve
      * @param requiredType the required type of the bean to retrieve
      * @param args arguments to use when creating a bean instance using explicit arguments
      * (only applied when creating a new instance as opposed to retrieving an existing one)
      * @param typeCheckOnly whether the instance is obtained for a type check,
      * not for actual use
      * @return an instance of the bean
      * @throws BeansException if the bean could not be created
      */
      @SuppressWarnings("unchecked")
      protected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,
          @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {

          //根据指定名称获取bean， 如果是别名转换为标准bean
        final String beanName = transformedBeanName(name);
        Object bean;

        // Eagerly check singleton cache for manually registered singletons.
        // 先从缓存中取单例bean， 不重复创建
        Object sharedInstance = getSingleton(beanName);
        if (sharedInstance != null && args == null) {
          if (logger.isTraceEnabled()) {
            if (isSingletonCurrentlyInCreation(beanName)) {
              logger.trace("Returning eagerly cached instance of singleton bean '" + beanName +
                  "' that is not fully initialized yet - a consequence of a circular reference");
            }
            else {
              logger.trace("Returning cached instance of singleton bean '" + beanName + "'");
            }
          }
          // 获取bean实例
          bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
        }

        else {
          // Fail if we're already creating this bean instance:
          // We're assumably within a circular reference.
          //缓存中没有bean
          if (isPrototypeCurrentlyInCreation(beanName)) {
            throw new BeanCurrentlyInCreationException(beanName);
          }

          // Check if bean definition exists in this factory.
          // 当前容器不存在bean，通过父容器查找
          BeanFactory parentBeanFactory = getParentBeanFactory();
          if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
            // Not found -> check parent.
            String nameToLookup = originalBeanName(name);
            if (parentBeanFactory instanceof AbstractBeanFactory) {
              return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                  nameToLookup, requiredType, args, typeCheckOnly);
            }
            else if (args != null) {
              // Delegation to parent with explicit args.
              return (T) parentBeanFactory.getBean(nameToLookup, args);
            }
            else if (requiredType != null) {
              // No args -> delegate to standard getBean method.
              return parentBeanFactory.getBean(nameToLookup, requiredType);
            }
            else {
              return (T) parentBeanFactory.getBean(nameToLookup);
            }
          }

          if (!typeCheckOnly) {
            markBeanAsCreated(beanName);
          }

          try {
          // 根据beanname获取bean定义， 主要解决子类父类公共属性问题
            final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
            checkMergedBeanDefinition(mbd, beanName, args);

            // Guarantee initialization of beans that the current bean depends on.
            //获取当前bean依赖的所有bean
            String[] dependsOn = mbd.getDependsOn();
            if (dependsOn != null) {
              for (String dep : dependsOn) {
                if (isDependent(beanName, dep)) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                      "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                }
                //把被依赖bean注册给当前bean
                registerDependentBean(dep, beanName);
                try {
                  getBean(dep);
                }
                catch (NoSuchBeanDefinitionException ex) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                      "'" + beanName + "' depends on missing bean '" + dep + "'", ex);
                }
              }
            }

            // Create bean instance.
            if (mbd.isSingleton()) {
              sharedInstance = getSingleton(beanName, () -> {
                try {
                  return createBean(beanName, mbd, args);
                }
                catch (BeansException ex) {
                  // Explicitly remove instance from singleton cache: It might have been put there
                  // eagerly by the creation process, to allow for circular reference resolution.
                  // Also remove any beans that received a temporary reference to the bean.
                  destroySingleton(beanName);
                  throw ex;
                }
              });
              bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
            }

            else if (mbd.isPrototype()) {
              // It's a prototype -> create a new instance.
              Object prototypeInstance = null;
              try {
                beforePrototypeCreation(beanName);
                prototypeInstance = createBean(beanName, mbd, args);
              }
              finally {
                afterPrototypeCreation(beanName);
              }
              bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
            }

            //既不是单例也不是原型bean创建， 根据bean配置的生命周期范围选择合适的方法， 一般是web项目中的 request, response, application等
            else {
              String scopeName = mbd.getScope();
              final Scope scope = this.scopes.get(scopeName);
              if (scope == null) {
                throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
              }
              try {
                Object scopedInstance = scope.get(beanName, () -> {
                  beforePrototypeCreation(beanName);
                  try {
                    return createBean(beanName, mbd, args);
                  }
                  finally {
                    afterPrototypeCreation(beanName);
                  }
                });
                bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
              }
              catch (IllegalStateException ex) {
                throw new BeanCreationException(beanName,
                    "Scope '" + scopeName + "' is not active for the current thread; consider " +
                    "defining a scoped proxy for this bean if you intend to refer to it from a singleton",
                    ex);
              }
            }
          }
          catch (BeansException ex) {
            cleanupAfterBeanCreationFailure(beanName);
            throw ex;
          }
        }

        // Check if required type matches the type of the actual bean instance.
        if (requiredType != null && !requiredType.isInstance(bean)) {
          try {
            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
            if (convertedBean == null) {
              throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
            }
            return convertedBean;
          }
          catch (TypeMismatchException ex) {
            if (logger.isTraceEnabled()) {
              logger.trace("Failed to convert bean '" + name + "' to required type '" +
                  ClassUtils.getQualifiedName(requiredType) + "'", ex);
            }
            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
          }
        }
        return (T) bean;
      } 
    #+END_SRC
    通过上面对向 IOC 容器获取 Bean 方法的分析， 我们可以看到在 Spring 中， 如果 Bean 定义的单例模式(Singleton)， 则容器在创建之前先从缓存中查找， 以确保整个容器中只存在一个实例对象。 如果 Bean定义的是原型模式(Prototype)， 则容器每次都会创建一个新的实例对象。 除此之外， Bean 定义还可以扩展为指定其生命周期范围。
    + createBean() --> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])
      #+BEGIN_SRC java
        protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
        throws BeanCreationException {

          if (logger.isTraceEnabled()) {
            logger.trace("Creating instance of bean '" + beanName + "'");
          }
          RootBeanDefinition mbdToUse = mbd;

          // Make sure bean class is actually resolved at this point, and
          // clone the bean definition in case of a dynamically resolved Class
          // which cannot be stored in the shared merged bean definition.
          //判断是否可以实例化， 可以通过当前类加载器处理
          Class<?> resolvedClass = resolveBeanClass(mbd, beanName);
          if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
            mbdToUse = new RootBeanDefinition(mbd);
            mbdToUse.setBeanClass(resolvedClass);
          }

          // Prepare method overrides.
          try {
            mbdToUse.prepareMethodOverrides();
          }
          catch (BeanDefinitionValidationException ex) {
            throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
                beanName, "Validation of method overrides failed", ex);
          }

          try {
            // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
            Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
            if (bean != null) {
              return bean;
            }
          }
          catch (Throwable ex) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
                "BeanPostProcessor before instantiation of bean failed", ex);
          }

          try {
          //创建bean入口， 
            Object beanInstance = doCreateBean(beanName, mbdToUse, args);
            if (logger.isTraceEnabled()) {
              logger.trace("Finished creating instance of bean '" + beanName + "'");
            }
            return beanInstance;
          }
          catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {
            // A previously detected exception with proper bean creation context already,
            // or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.
            throw ex;
          }
          catch (Throwable ex) {
            throw new BeanCreationException(
                mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", ex);
          }
        }

      #+END_SRC
      + docreatebean
        #+BEGIN_SRC java
          protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
              throws BeanCreationException {

            // Instantiate the bean.
            // 封装创建的bean对象
            BeanWrapper instanceWrapper = null;
            if (mbd.isSingleton()) {
              instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
            }
            if (instanceWrapper == null) {
              instanceWrapper = createBeanInstance(beanName, mbd, args);
            }
            final Object bean = instanceWrapper.getWrappedInstance();
            //获取实例化对象类型
            Class<?> beanType = instanceWrapper.getWrappedClass();
            if (beanType != NullBean.class) {
              mbd.resolvedTargetType = beanType;
            }

            // Allow post-processors to modify the merged bean definition.
            synchronized (mbd.postProcessingLock) {
              if (!mbd.postProcessed) {
                try {
                  applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
                }
                catch (Throwable ex) {
                  throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                      "Post-processing of merged bean definition failed", ex);
                }
                mbd.postProcessed = true;
              }
            }

            // Eagerly cache singletons to be able to resolve circular references
            // even when triggered by lifecycle interfaces like BeanFactoryAware.
            // 防止循环引用
            boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
                isSingletonCurrentlyInCreation(beanName));
            if (earlySingletonExposure) {
              if (logger.isTraceEnabled()) {
                logger.trace("Eagerly caching bean '" + beanName +
                    "' to allow for resolving potential circular references");
              }
              // 尽早持有对象引用
              addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
            }

            // Initialize the bean instance.
            Object exposedObject = bean;
            try {
            // 封装实例对象，并将xml配置中属性赋值给对象
              populateBean(beanName, mbd, instanceWrapper);
              //初始化bean
              exposedObject = initializeBean(beanName, exposedObject, mbd);
            }
            catch (Throwable ex) {
              if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {
                throw (BeanCreationException) ex;
              }
              else {
                throw new BeanCreationException(
                    mbd.getResourceDescription(), beanName, "Initialization of bean failed", ex);
              }
            }

            if (earlySingletonExposure) {
            //获取指定名称单例bean对象
              Object earlySingletonReference = getSingleton(beanName, false);
              if (earlySingletonReference != null) {
                if (exposedObject == bean) {
                //当前实例化bean初始化完成
                  exposedObject = earlySingletonReference;
                }
                //发生循环引用不允许创建
                else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
                  String[] dependentBeans = getDependentBeans(beanName);
                  Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);
                  // 获取当前bean所依赖的其他bean
                  for (String dependentBean : dependentBeans) {
                    if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                      actualDependentBeans.add(dependentBean);
                    }
                  }
                  if (!actualDependentBeans.isEmpty()) {
                    throw new BeanCurrentlyInCreationException(beanName,
                        "Bean with name '" + beanName + "' has been injected into other beans [" +
                        StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                        "] in its raw version as part of a circular reference, but has eventually been " +
                        "wrapped. This means that said other beans do not use the final version of the " +
                        "bean. This is often the result of over-eager type matching - consider using " +
                        "'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.");
                  }
                }
              }
            }

            // Register bean as disposable.
            //注册完成依赖注入的bean
            try {
              registerDisposableBeanIfNecessary(beanName, bean, mbd);
            }
            catch (BeanDefinitionValidationException ex) {
              throw new BeanCreationException(
                  mbd.getResourceDescription(), beanName, "Invalid destruction signature", ex);
            }

            return exposedObject;
          } 
        #+END_SRC
        + createBeanInstance(beanName, mbd, args) 生成java对象实例
          #+BEGIN_SRC java
            protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
              // Make sure bean class is actually resolved at this point.
              Class<?> beanClass = resolveBeanClass(mbd, beanName);

              if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {
                throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                    "Bean class isn't public, and non-public access not allowed: " + beanClass.getName());
              }

              Supplier<?> instanceSupplier = mbd.getInstanceSupplier();
              if (instanceSupplier != null) {
                return obtainFromSupplier(instanceSupplier, beanName);
              }

              //实例化对象
              if (mbd.getFactoryMethodName() != null)  {
                return instantiateUsingFactoryMethod(beanName, mbd, args);
              }

              // Shortcut when re-creating the same bean...
              // 使用自动装配进行实例化
              boolean resolved = false;
              boolean autowireNecessary = false;
              if (args == null) {
                synchronized (mbd.constructorArgumentLock) {
                  if (mbd.resolvedConstructorOrFactoryMethod != null) {
                    resolved = true;
                    autowireNecessary = mbd.constructorArgumentsResolved;
                  }
                }
              }
              if (resolved) {
                if (autowireNecessary) {
                //配置了自动装配属性， 根据属性类型进行注入
                  return autowireConstructor(beanName, mbd, null, null);
                }
                else {
                // 默认无参构造方法初始化
                  return instantiateBean(beanName, mbd);
                }
              }

              // Need to determine the constructor...
              // 使用bean构造方法初始化
              Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
              if (ctors != null ||
                  mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||
                  mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {
                  // 根据自动装配属性调用匹配的构造方法进行初始化
                return autowireConstructor(beanName, mbd, ctors, args);
              }

              // No special handling: simply use no-arg constructor.
              return instantiateBean(beanName, mbd);
            }

            protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {
              try {
                Object beanInstance;
                final BeanFactory parent = this;
                //获取系统安全接口， jdk标准api
                if (System.getSecurityManager() != null) {
                // 根据实例化策略创建实力对象
                  beanInstance = AccessController.doPrivileged((PrivilegedAction<Object>) () ->
                      getInstantiationStrategy().instantiate(mbd, beanName, parent),
                      getAccessControlContext());
                }
                else {
                //
                  beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
                }
                BeanWrapper bw = new BeanWrapperImpl(beanInstance);
                initBeanWrapper(bw);
                return bw;
              }
              catch (Throwable ex) {
                throw new BeanCreationException(
                    mbd.getResourceDescription(), beanName, "Instantiation of bean failed", ex);
              }
            }
          #+END_SRC
          + instantiate -->org.springframework.beans.factory.support.SimpleInstantiationStrategy#instantiate(org.springframework.beans.factory.support.RootBeanDefinition, java.lang.String, org.springframework.beans.factory.BeanFactory)
            #+BEGIN_SRC java
              public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {
                // Don't override the class with CGLIB if no overrides.
                if (!bd.hasMethodOverrides()) {
                  Constructor<?> constructorToUse;
                  synchronized (bd.constructorArgumentLock) {
                  // 获取对象的构造或工厂方法
                    constructorToUse = (Constructor<?>) bd.resolvedConstructorOrFactoryMethod;
                    // 如果没有构造或工厂
                    if (constructorToUse == null) {
                    //使用jdk反射 来获取构造器
                      final Class<?> clazz = bd.getBeanClass();
                      if (clazz.isInterface()) {
                        throw new BeanInstantiationException(clazz, "Specified class is an interface");
                      }
                      try {
                        if (System.getSecurityManager() != null) {
                          constructorToUse = AccessController.doPrivileged(
                              (PrivilegedExceptionAction<Constructor<?>>) clazz::getDeclaredConstructor);
                        }
                        else {
                          constructorToUse =	clazz.getDeclaredConstructor();
                        }
                        bd.resolvedConstructorOrFactoryMethod = constructorToUse;
                      }
                      catch (Throwable ex) {
                        throw new BeanInstantiationException(clazz, "No default constructor found", ex);
                      }
                    }
                  }
                  // 使用构造方法.newinstance实例化
                  return BeanUtils.instantiateClass(constructorToUse);
                }
                else {
                  // Must generate CGLIB subclass.
                  // 使用cglib进行实例化
                  return instantiateWithMethodInjection(bd, beanName, owner);
                }
              }
            #+END_SRC
          + instantiateWithMethodInjection --> org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy.CglibSubclassCreator#instantiate
            #+BEGIN_SRC java
                public Object instantiate(@Nullable Constructor<?> ctor, Object... args) {
                // 创建代理子类
                  Class<?> subclass = createEnhancedSubclass(this.beanDefinition);
                  Object instance;
                  if (ctor == null) {
                    instance = BeanUtils.instantiateClass(subclass);
                  }
                  else {
                    try {
                      Constructor<?> enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());
                      instance = enhancedSubclassConstructor.newInstance(args);
                    }
                    catch (Exception ex) {
                      throw new BeanInstantiationException(this.beanDefinition.getBeanClass(),
                          "Failed to invoke constructor for CGLIB enhanced subclass [" + subclass.getName() + "]", ex);
                    }
                  }
                  // SPR-10785: set callbacks directly on the instance instead of in the
                  // enhanced class (via the Enhancer) in order to avoid memory leaks.
                  Factory factory = (Factory) instance;
                  factory.setCallbacks(new Callback[] {NoOp.INSTANCE,
                      new LookupOverrideMethodInterceptor(this.beanDefinition, this.owner),
                      new ReplaceOverrideMethodInterceptor(this.beanDefinition, this.owner)});
                  return instance;
                }
            #+END_SRC
            + createEnhancedSubclass
              #+BEGIN_SRC java
                  private Class<?> createEnhancedSubclass(RootBeanDefinition beanDefinition) {
                    Enhancer enhancer = new Enhancer();
                    // bean本身作为基类
                    enhancer.setSuperclass(beanDefinition.getBeanClass());
                    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
                    if (this.owner instanceof ConfigurableBeanFactory) {
                      ClassLoader cl = ((ConfigurableBeanFactory) this.owner).getBeanClassLoader();
                      enhancer.setStrategy(new ClassLoaderAwareGeneratorStrategy(cl));
                    }
                    enhancer.setCallbackFilter(new MethodOverrideCallbackFilter(beanDefinition));
                    enhancer.setCallbackTypes(CALLBACK_TYPES);
                    return enhancer.createClass();
                  }
              #+END_SRC
        + populateBean(beanName, mbd, instanceWrapper) 对bean配置的属性进行注入;
          #+BEGIN_SRC java
            protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
              if (bw == null) {
                if (mbd.hasPropertyValues()) {
                  throw new BeanCreationException(
                      mbd.getResourceDescription(), beanName, "Cannot apply property values to null instance");
                }
                else {
                  // Skip property population phase for null instance.
                  return;
                }
              }

              // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
              // state of the bean before properties are set. This can be used, for example,
              // to support styles of field injection.
              boolean continueWithPropertyPopulation = true;

              if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
                for (BeanPostProcessor bp : getBeanPostProcessors()) {
                  if (bp instanceof InstantiationAwareBeanPostProcessor) {
                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
                    if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
                      continueWithPropertyPopulation = false;
                      break;
                    }
                  }
                }
              }

              if (!continueWithPropertyPopulation) {
                return;
              }

              //获取bean定义时设置的属性值
              PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);

              if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||
                  mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
                MutablePropertyValues newPvs = new MutablePropertyValues(pvs);

                // Add property values based on autowire by name if applicable.
                if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {
                  autowireByName(beanName, mbd, bw, newPvs);
                }

                // Add property values based on autowire by type if applicable.
                if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
                  autowireByType(beanName, mbd, bw, newPvs);
                }

                pvs = newPvs;
              }


              if (pvs != null) {
              // 属性注入
                applyPropertyValues(beanName, mbd, bw, pvs);
              }
            } 
          #+END_SRC
          + applyPropertyValues
            #+BEGIN_SRC java
              protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) {
                if (pvs.isEmpty()) {
                  return;
                }

                if (System.getSecurityManager() != null && bw instanceof BeanWrapperImpl) {
                // jdk 安全机制
                  ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());
                }

                // 封装属性值
                MutablePropertyValues mpvs = null;
                List<PropertyValue> original;

                if (pvs instanceof MutablePropertyValues) {
                  mpvs = (MutablePropertyValues) pvs;
                  if (mpvs.isConverted()) {
                    // Shortcut: use the pre-converted values as-is.
                    try {
                      bw.setPropertyValues(mpvs);
                      return;
                    }
                    catch (BeansException ex) {
                      throw new BeanCreationException(
                          mbd.getResourceDescription(), beanName, "Error setting property values", ex);
                    }
                  }
                  // 获取属性原始类型
                  original = mpvs.getPropertyValueList();
                }
                else {
                  original = Arrays.asList(pvs.getPropertyValues());
                }

                // 获取用户自定义类型转换(扩展点)
                TypeConverter converter = getCustomTypeConverter();
                if (converter == null) {
                  converter = bw;
                }
                
                // 创建bean定义属性解析器, 将属性解析到实际对象中
                BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);

                // Create a deep copy, resolving any references for values.
                List<PropertyValue> deepCopy = new ArrayList<>(original.size());
                boolean resolveNecessary = false;
                for (PropertyValue pv : original) {
                //属性值不需要转换
                  if (pv.isConverted()) {
                    deepCopy.add(pv);
                  }
                  else {
                    String propertyName = pv.getName();
                    // 转换前属性值
                    Object originalValue = pv.getValue();
                    Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);
                    // 转换后属性值
                    Object convertedValue = resolvedValue;
                    boolean convertible = bw.isWritableProperty(propertyName) &&
                        !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);
                    if (convertible) {
                    // 使用自定义转换器转换
                      convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);
                    }
                    // Possibly store converted value in merged bean definition,
                    // in order to avoid re-conversion for every created bean instance.
                    // 存储转换属性，避免每次的转换工作
                    if (resolvedValue == originalValue) {
                      if (convertible) {
                        pv.setConvertedValue(convertedValue);
                      }
                      deepCopy.add(pv);
                    }
                    else if (convertible && originalValue instanceof TypedStringValue &&
                        !((TypedStringValue) originalValue).isDynamic() &&
                        !(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {
                      pv.setConvertedValue(convertedValue);
                      deepCopy.add(pv);
                    }
                    else {
                      resolveNecessary = true;
                      deepCopy.add(new PropertyValue(pv, convertedValue));
                    }
                  }
                }
                if (mpvs != null && !resolveNecessary) {
                // 标记属性已经转换过
                  mpvs.setConverted();
                }

                // Set our (possibly massaged) deep copy.
                try {
                // 属性依赖注入
                  bw.setPropertyValues(new MutablePropertyValues(deepCopy));
                }
                catch (BeansException ex) {
                  throw new BeanCreationException(
                      mbd.getResourceDescription(), beanName, "Error setting property values", ex);
                }
              }
 
            #+END_SRC
            + resolveValueIfNecessary
              #+BEGIN_SRC java
                public Object resolveValueIfNecessary(Object argName, @Nullable Object value) {
                  // We must check each value to see whether it requires a runtime reference
                  // to another bean to be resolved.
                  // 对引用类型解析
                  if (value instanceof RuntimeBeanReference) {
                    RuntimeBeanReference ref = (RuntimeBeanReference) value;
                    // 引用类型属性进行解析
                    return resolveReference(argName, ref);
                  }
                  else if (value instanceof RuntimeBeanNameReference) {
                    String refName = ((RuntimeBeanNameReference) value).getBeanName();
                    refName = String.valueOf(doEvaluate(refName));
                    if (!this.beanFactory.containsBean(refName)) {
                      throw new BeanDefinitionStoreException(
                          "Invalid bean name '" + refName + "' in bean reference for " + argName);
                    }
                    return refName;
                  }
                  else if (value instanceof BeanDefinitionHolder) {
                    // Resolve BeanDefinitionHolder: contains BeanDefinition with name and aliases.
                    // 对bean类型属性解析， 主要是内部类
                    BeanDefinitionHolder bdHolder = (BeanDefinitionHolder) value;
                    return resolveInnerBean(argName, bdHolder.getBeanName(), bdHolder.getBeanDefinition());
                  }
                  else if (value instanceof BeanDefinition) {
                    // Resolve plain BeanDefinition, without contained name: use dummy name.
                    BeanDefinition bd = (BeanDefinition) value;
                    String innerBeanName = "(inner bean)" + BeanFactoryUtils.GENERATED_BEAN_NAME_SEPARATOR +
                        ObjectUtils.getIdentityHexString(bd);
                    return resolveInnerBean(argName, innerBeanName, bd);
                  }
                  // 解析数组类型
                  else if (value instanceof ManagedArray) {
                    // May need to resolve contained runtime references.
                    ManagedArray array = (ManagedArray) value;
                    // 获取数组元素类型
                    Class<?> elementType = array.resolvedElementType;
                    if (elementType == null) {
                      String elementTypeName = array.getElementTypeName();
                      if (StringUtils.hasText(elementTypeName)) {
                        try {
                        // 反射机制创建制定类型对象
                          elementType = ClassUtils.forName(elementTypeName, this.beanFactory.getBeanClassLoader());
                          array.resolvedElementType = elementType;
                        }
                        catch (Throwable ex) {
                          // Improve the message by showing the context.
                          throw new BeanCreationException(
                              this.beanDefinition.getResourceDescription(), this.beanName,
                              "Error resolving array type for " + argName, ex);
                        }
                      }
                      else {
                      //如果没有获取到数组或元素类型, 则返回object
                        elementType = Object.class;
                      }
                    }
                    // 创建制定类型数组
                    return resolveManagedArray(argName, (List<?>) value, elementType);
                  }
                  else if (value instanceof ManagedList) {
                    // May need to resolve contained runtime references.
                    return resolveManagedList(argName, (List<?>) value);
                  }
                  else if (value instanceof ManagedSet) {
                    // May need to resolve contained runtime references.
                    return resolveManagedSet(argName, (Set<?>) value);
                  }
                  else if (value instanceof ManagedMap) {
                    // May need to resolve contained runtime references.
                    return resolveManagedMap(argName, (Map<?, ?>) value);
                  }
                  else if (value instanceof ManagedProperties) {
                    Properties original = (Properties) value;
                    Properties copy = new Properties();
                    original.forEach((propKey, propValue) -> {
                      if (propKey instanceof TypedStringValue) {
                        propKey = evaluate((TypedStringValue) propKey);
                      }
                      if (propValue instanceof TypedStringValue) {
                        propValue = evaluate((TypedStringValue) propValue);
                      }
                      if (propKey == null || propValue == null) {
                        throw new BeanCreationException(
                            this.beanDefinition.getResourceDescription(), this.beanName,
                            "Error converting Properties key/value pair for " + argName + ": resolved to null");
                      }
                      copy.put(propKey, propValue);
                    });
                    return copy;
                  }
                  // 解析字符串类型属性
                  else if (value instanceof TypedStringValue) {
                    // Convert value to target type here.
                    TypedStringValue typedStringValue = (TypedStringValue) value;
                    Object valueObject = evaluate(typedStringValue);
                    try {
                      Class<?> resolvedTargetType = resolveTargetType(typedStringValue);
                      if (resolvedTargetType != null) {
                        return this.typeConverter.convertIfNecessary(valueObject, resolvedTargetType);
                      }
                      else {
                        return valueObject;
                      }
                    }
                    catch (Throwable ex) {
                      // Improve the message by showing the context.
                      throw new BeanCreationException(
                          this.beanDefinition.getResourceDescription(), this.beanName,
                          "Error converting typed String value for " + argName, ex);
                    }
                  }
                  else if (value instanceof NullBean) {
                    return null;
                  }
                  else {
                    return evaluate(value);
                  }
                } 
              #+END_SRC
            + setPropertyValues --> org.springframework.beans.AbstractPropertyAccessor#setPropertyValues(org.springframework.beans.PropertyValues, boolean, boolean)
              #+BEGIN_SRC java
              	public void setPropertyValues(PropertyValues pvs, boolean ignoreUnknown, boolean ignoreInvalid)
                    throws BeansException {

                  List<PropertyAccessException> propertyAccessExceptions = null;
                  List<PropertyValue> propertyValues = (pvs instanceof MutablePropertyValues ?
                      ((MutablePropertyValues) pvs).getPropertyValueList() : Arrays.asList(pvs.getPropertyValues()));
                  for (PropertyValue pv : propertyValues) {
                    try {
                      // This method may throw any BeansException, which won't be caught
                      // here, if there is a critical failure such as no matching field.
                      // We can attempt to deal only with less serious exceptions.
                      setPropertyValue(pv);
                    }
                    catch (NotWritablePropertyException ex) {
                      if (!ignoreUnknown) {
                        throw ex;
                      }
                      // Otherwise, just ignore it and continue...
                    }
                    catch (NullValueInNestedPathException ex) {
                      if (!ignoreInvalid) {
                        throw ex;
                      }
                      // Otherwise, just ignore it and continue...
                    }
                    catch (PropertyAccessException ex) {
                      if (propertyAccessExceptions == null) {
                        propertyAccessExceptions = new ArrayList<>();
                      }
                      propertyAccessExceptions.add(ex);
                    }
                  }

                  // If we encountered individual exceptions, throw the composite exception.
                  if (propertyAccessExceptions != null) {
                    PropertyAccessException[] paeArray = propertyAccessExceptions.toArray(new PropertyAccessException[0]);
                    throw new PropertyBatchUpdateException(paeArray);
                  }
                }
              #+END_SRC
              + setPropertyValue --> org.springframework.beans.AbstractNestablePropertyAccessor#setPropertyValue(org.springframework.beans.AbstractNestablePropertyAccessor.PropertyTokenHolder, org.springframework.beans.PropertyValue)
                #+BEGIN_SRC java
                  protected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {
                    if (tokens.keys != null) {
                      processKeyedProperty(tokens, pv);
                    }
                    else {
                      processLocalProperty(tokens, pv);
                    }
                  } 
                #+END_SRC
                + processKeyedProperty
                  #+BEGIN_SRC java
                    private void processKeyedProperty(PropertyTokenHolder tokens, PropertyValue pv) {
                      Object propValue = getPropertyHoldingValue(tokens);
                      PropertyHandler ph = getLocalPropertyHandler(tokens.actualName);
                      if (ph == null) {
                        throw new InvalidPropertyException(
                            getRootClass(), this.nestedPath + tokens.actualName, "No property handler found");
                      }
                      Assert.state(tokens.keys != null, "No token keys");
                      String lastKey = tokens.keys[tokens.keys.length - 1];

                      // 注入array类型属性值
                      if (propValue.getClass().isArray()) {
                        Class<?> requiredType = propValue.getClass().getComponentType();
                        int arrayIndex = Integer.parseInt(lastKey);
                        Object oldValue = null;
                        try {
                          if (isExtractOldValueForEditor() && arrayIndex < Array.getLength(propValue)) {
                            oldValue = Array.get(propValue, arrayIndex);
                          }
                          Object convertedValue = convertIfNecessary(tokens.canonicalName, oldValue, pv.getValue(),
                              requiredType, ph.nested(tokens.keys.length));
                          int length = Array.getLength(propValue);
                          if (arrayIndex >= length && arrayIndex < this.autoGrowCollectionLimit) {
                            Class<?> componentType = propValue.getClass().getComponentType();
                            Object newArray = Array.newInstance(componentType, arrayIndex + 1);
                            System.arraycopy(propValue, 0, newArray, 0, length);
                            setPropertyValue(tokens.actualName, newArray);
                            propValue = getPropertyValue(tokens.actualName);
                          }
                          Array.set(propValue, arrayIndex, convertedValue);
                        }
                        catch (IndexOutOfBoundsException ex) {
                          throw new InvalidPropertyException(getRootClass(), this.nestedPath + tokens.canonicalName,
                              "Invalid array index in property path '" + tokens.canonicalName + "'", ex);
                        }
                      }

                      else if (propValue instanceof List) {
                        Class<?> requiredType = ph.getCollectionType(tokens.keys.length);
                        List<Object> list = (List<Object>) propValue;
                        int index = Integer.parseInt(lastKey);
                        Object oldValue = null;
                        if (isExtractOldValueForEditor() && index < list.size()) {
                          oldValue = list.get(index);
                        }
                        Object convertedValue = convertIfNecessary(tokens.canonicalName, oldValue, pv.getValue(),
                            requiredType, ph.nested(tokens.keys.length));
                        int size = list.size();
                        if (index >= size && index < this.autoGrowCollectionLimit) {
                          for (int i = size; i < index; i++) {
                            try {
                              list.add(null);
                            }
                            catch (NullPointerException ex) {
                              throw new InvalidPropertyException(getRootClass(), this.nestedPath + tokens.canonicalName,
                                  "Cannot set element with index " + index + " in List of size " +
                                  size + ", accessed using property path '" + tokens.canonicalName +
                                  "': List does not support filling up gaps with null elements");
                            }
                          }
                          list.add(convertedValue);
                        }
                        else {
                          try {
                            list.set(index, convertedValue);
                          }
                          catch (IndexOutOfBoundsException ex) {
                            throw new InvalidPropertyException(getRootClass(), this.nestedPath + tokens.canonicalName,
                                "Invalid list index in property path '" + tokens.canonicalName + "'", ex);
                          }
                        }
                      }

                      else if (propValue instanceof Map) {
                        Class<?> mapKeyType = ph.getMapKeyType(tokens.keys.length);
                        Class<?> mapValueType = ph.getMapValueType(tokens.keys.length);
                        Map<Object, Object> map = (Map<Object, Object>) propValue;
                        // IMPORTANT: Do not pass full property name in here - property editors
                        // must not kick in for map keys but rather only for map values.
                        TypeDescriptor typeDescriptor = TypeDescriptor.valueOf(mapKeyType);
                        Object convertedMapKey = convertIfNecessary(null, null, lastKey, mapKeyType, typeDescriptor);
                        Object oldValue = null;
                        if (isExtractOldValueForEditor()) {
                          oldValue = map.get(convertedMapKey);
                        }
                        // Pass full property name and old value in here, since we want full
                        // conversion ability for map values.
                        Object convertedMapValue = convertIfNecessary(tokens.canonicalName, oldValue, pv.getValue(),
                            mapValueType, ph.nested(tokens.keys.length));
                        map.put(convertedMapKey, convertedMapValue);
                      }

                      else {
                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + tokens.canonicalName,
                            "Property referenced in indexed property path '" + tokens.canonicalName +
                            "' is neither an array nor a List nor a Map; returned value was [" + propValue + "]");
                      }
                    } 
                  #+END_SRC
  + 总结
    通过对上面注入依赖代码的分析， 我们已经明白了 Spring IOC 容器是如何将属性的值注入到 Bean 实例对象中去的：
      + 对于集合类型的属性， 将其属性值解析为目标类型的集合后直接赋值给属性。
      + 对于非集合类型的属性， 大量使用了 JDK 的反射和内省机制， 通过属性的 getter 方法(readerMethod)获取指定属性注入以前的值， 同时调用属性的 setter 方法(writer Method)为属性设置注入后的值。 
** DI 基于annotation注入
    从Spring2.0以后的版本中，Spring也引入了基于注解(Annotation)方式的配置，注解(Annotation)是JDK1.5中引入的一个新特性，用于简化Bean的配置，某些场合可以取代XML配置文件。开发人员对注解(Annotation)的态度也是萝卜青菜各有所爱，个人认为注解可以大大简化配置，提高开发速度，同时也不能完全取代XML配置方式，XML方式更加灵活，并且发展的相对成熟，这种配置方式为大多数Spring开发者熟悉；注解方式使用起来非常简洁，但是尚处于发展阶段，XML配置文件和注解(Annotation)可以相互配合使用。SpringIOC容器对于类级别的注解和类内部的注解分以下两种处理策略：
    +类级别的注解：如@Component、@Repository、@Controller、@Service以及JavaEE6的@ManagedBean和@Named注解，都是添加在类上面的类级别注解，Spring容器根据注解的过滤规则扫描读取注解Bean定义类，并将其注册到SpringIOC容器中。
    +类内部的注解：如@Autowire、@Value、@Resource以及EJB和WebService相关的注解等，都是添加在类内部的字段或者方法上的类内部注解，SpringIOC容器通过Bean后置注解处理器解析Bean内部的注解。
    + AnnotationConfigApplicationContext对注解Bean初始化：Spring中，管理注解Bean定义的容器有两个：AnnotationConfigApplicationContext和接依赖于注解作为容器配置信息来源的IOC容器。AnnotationConfigWebApplicationContext是AnnotationConfigApplicationContext的web版本，两者的用法以及对注解的处理方式几乎没有什么差别
      #+BEGIN_SRC java
          public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry {

          //保存一个读取注解的 Bean 定义读取器， 并将其设置到容器中
          private final AnnotatedBeanDefinitionReader reader;
          //保存一个扫描指定类路径中注解 Bean 定义的扫描器， 并将其设置到容器中
          private final ClassPathBeanDefinitionScanner scanner;


          /**
          * Create a new AnnotationConfigApplicationContext that needs to be populated
          * through {@link #register} calls and then manually {@linkplain #refresh refreshed}.
          */
          //默认构造函数， 初始化一个空容器， 容器不包含任何 Bean 信息， 需要在稍后通过调用其 register()
          //方法注册配置类， 并调用 refresh()方法刷新容器， 触发容器对注解 Bean 的载入、 解析和注册过程
          public AnnotationConfigApplicationContext() {
            this.reader = new AnnotatedBeanDefinitionReader(this);
            this.scanner = new ClassPathBeanDefinitionScanner(this);
          }

          /**
          * Create a new AnnotationConfigApplicationContext with the given DefaultListableBeanFactory.
          * @param beanFactory the DefaultListableBeanFactory instance to use for this context
          */
          public AnnotationConfigApplicationContext(DefaultListableBeanFactory beanFactory) {
            super(beanFactory);
            this.reader = new AnnotatedBeanDefinitionReader(this);
            this.scanner = new ClassPathBeanDefinitionScanner(this);
          }

          /**
          * Create a new AnnotationConfigApplicationContext, deriving bean definitions
          * from the given annotated classes and automatically refreshing the context.
          * @param annotatedClasses one or more annotated classes,
          * e.g. {@link Configuration @Configuration} classes
          */
          //最常用的构造函数， 通过将涉及到的配置类传递给该构造函数， 以实现将相应配置类中的 Bean 自动注册到容器中
          public AnnotationConfigApplicationContext(Class<?>... annotatedClasses) {
            this();
            register(annotatedClasses);
            refresh();
          }

          /**
          * Create a new AnnotationConfigApplicationContext, scanning for bean definitions
          * in the given packages and automatically refreshing the context.
          * @param basePackages the packages to check for annotated classes
          //该构造函数会自动扫描以给定的包及其子包下的所有类， 并自动识别所有的 Spring Bean， 将其注册到容器中*/
          public AnnotationConfigApplicationContext(String... basePackages) {
            this();
            scan(basePackages);
            refresh();
          }


          /**
          * Propagates the given custom {@code Environment} to the underlying
          * {@link AnnotatedBeanDefinitionReader} and {@link ClassPathBeanDefinitionScanner}.
          */
          @Override
          public void setEnvironment(ConfigurableEnvironment environment) {
            super.setEnvironment(environment);
            this.reader.setEnvironment(environment);
            this.scanner.setEnvironment(environment);
          }

          /**
          * Provide a custom {@link BeanNameGenerator} for use with {@link AnnotatedBeanDefinitionReader}
          * and/or {@link ClassPathBeanDefinitionScanner}, if any.
          * <p>Default is {@link org.springframework.context.annotation.AnnotationBeanNameGenerator}.
          * <p>Any call to this method must occur prior to calls to {@link #register(Class...)}
          * and/or {@link #scan(String...)}.
          * @see AnnotatedBeanDefinitionReader#setBeanNameGenerator
          * @see ClassPathBeanDefinitionScanner#setBeanNameGenerator
          */
          //为容器的注解 Bean 读取器和注解 Bean 扫描器设置 Bean 名称产生器
          public void setBeanNameGenerator(BeanNameGenerator beanNameGenerator) {
            this.reader.setBeanNameGenerator(beanNameGenerator);
            this.scanner.setBeanNameGenerator(beanNameGenerator);
            getBeanFactory().registerSingleton(
                AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator);
          }

          /**
          * Set the {@link ScopeMetadataResolver} to use for detected bean classes.
          * <p>The default is an {@link AnnotationScopeMetadataResolver}.
          * <p>Any call to this method must occur prior to calls to {@link #register(Class...)}
          * and/or {@link #scan(String...)}.
          */
          //为容器的注解 Bean 读取器和注解 Bean 扫描器设置作用范围元信息解析器
          public void setScopeMetadataResolver(ScopeMetadataResolver scopeMetadataResolver) {
            this.reader.setScopeMetadataResolver(scopeMetadataResolver);
            this.scanner.setScopeMetadataResolver(scopeMetadataResolver);
          }


          //---------------------------------------------------------------------
          // Implementation of AnnotationConfigRegistry
          //---------------------------------------------------------------------

          /**
          * Register one or more annotated classes to be processed.
          * <p>Note that {@link #refresh()} must be called in order for the context
          * to fully process the new classes.
          * @param annotatedClasses one or more annotated classes,
          * e.g. {@link Configuration @Configuration} classes
          * @see #scan(String...)
          * @see #refresh()
          */
          //为容器注册一个要被处理的注解 Bean， 新注册的 Bean， 必须手动调用容器的
          //refresh()方法刷新容器， 触发容器对新注册的 Bean 的处理
          public void register(Class<?>... annotatedClasses) {
            Assert.notEmpty(annotatedClasses, "At least one annotated class must be specified");
            this.reader.register(annotatedClasses);
          }

          /**
          * Perform a scan within the specified base packages.
          * <p>Note that {@link #refresh()} must be called in order for the context
          * to fully process the new classes.
          * @param basePackages the packages to check for annotated classes
          * @see #register(Class...)
          * @see #refresh()
          */
          //扫描指定包路径及其子包下的注解类， 为了使新添加的类被处理， 必须手动调用
          //refresh()方法刷新容器
          public void scan(String... basePackages) {
            Assert.notEmpty(basePackages, "At least one base package must be specified");
            this.scanner.scan(basePackages);
          }


          //---------------------------------------------------------------------
          // Convenient methods for registering individual beans
          //---------------------------------------------------------------------

          /**
          * Register a bean from the given bean class, deriving its metadata from
          * class-declared annotations, and optionally providing explicit constructor
          * arguments for consideration in the autowiring process.
          * <p>The bean name will be generated according to annotated component rules.
          * @param annotatedClass the class of the bean
          * @param constructorArguments argument values to be fed into Spring's
          * constructor resolution algorithm, resolving either all arguments or just
          * specific ones, with the rest to be resolved through regular autowiring
          * (may be {@code null} or empty)
          * @since 5.0
          */
          public <T> void registerBean(Class<T> annotatedClass, Object... constructorArguments) {
            registerBean(null, annotatedClass, constructorArguments);
          }

          /**
          * Register a bean from the given bean class, deriving its metadata from
          * class-declared annotations, and optionally providing explicit constructor
          * arguments for consideration in the autowiring process.
          * @param beanName the name of the bean (may be {@code null})
          * @param annotatedClass the class of the bean
          * @param constructorArguments argument values to be fed into Spring's
          * constructor resolution algorithm, resolving either all arguments or just
          * specific ones, with the rest to be resolved through regular autowiring
          * (may be {@code null} or empty)
          * @since 5.0
          */
          public <T> void registerBean(@Nullable String beanName, Class<T> annotatedClass, Object... constructorArguments) {
            this.reader.doRegisterBean(annotatedClass, null, beanName, null,
                bd -> {
                  for (Object arg : constructorArguments) {
                    bd.getConstructorArgumentValues().addGenericArgumentValue(arg);
                  }
                });
          }

          @Override
          public <T> void registerBean(@Nullable String beanName, Class<T> beanClass, @Nullable Supplier<T> supplier,
              BeanDefinitionCustomizer... customizers) {

            this.reader.doRegisterBean(beanClass, supplier, beanName, null, customizers);
          }

        } 
      #+END_SRC 
      通过对 AnnotationConfigApplicationContext 的源码分析， 我们了解到 Spring 对注解的处理分为两种方式：
      + 直接将注解 Bean 注册到容器中：
        可以在初始化容器时注册； 也可以在容器创建之后手动调用注册方法向容器注册， 然后通过手动刷新容器， 使得容器对注册的注解 Bean 进行处理。
      + 通过扫描指定的包及其子包下的所有类：
        在初始化注解容器时指定要自动扫描的路径， 如果容器创建以后向给定路径动态添加了注解 Bean， 则需要手动调用容器扫描的方法， 然后手动刷新容器， 使得容器对所注册的 Bean 进行处理。接下来， 将会对两种处理方式详细分析其实现过程。
      + AnnotationConfigApplicationContext 注册注解 Bean：
      当创建注解处理容器时， 如果传入的初始参数是具体的注解 Bean 定义类时， 注解容器读取并注册。
      + AnnotationConfigApplicationContext 通过调用注解Bean定义读取器AnnotatedBeanDefinitionReader 的 register 方法向容器注册指定的注解 Bean， 注解 Bean 定义读取器向容器注册注解 Bean 的源码如下：
        + registerBean(注册) -->org.springframework.context.annotation.AnnotatedBeanDefinitionReader#doRegisterBean
          #+BEGIN_SRC java
          <T> void doRegisterBean(Class<T> annotatedClass, @Nullable Supplier<T> instanceSupplier, @Nullable String name,
              @Nullable Class<? extends Annotation>[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) {
            //根据指定的注解 Bean 定义类， 创建 Spring 容器中对注解 Bean 的封装的数据结构 
            AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);
            if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {
              return;
            }

            abd.setInstanceSupplier(instanceSupplier);
            //解析注解 Bean 定义的作用域， 若@Scope("prototype")， 则 Bean 为原型类型；
            //若@Scope("singleton")， 则 Bean 为单态类型
            ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
            //为注解 Bean 定义设置作用域
            abd.setScope(scopeMetadata.getScopeName());
            //为注解 Bean 定义生成 Bean 名称
            String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));

            //处理注解 Bean 定义中的通用注解
            AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);

            //如果在向容器注册注解 Bean 定义时， 使用了额外的限定符注解， 则解析限定符注解。
            //主要是配置的关于 autowiring 自动依赖注入装配的限定条件， 即@Qualifier 注解
            //Spring 自动依赖注入装配默认是按类型装配， 如果使用@Qualifier 则按名称
            if (qualifiers != null) {
              for (Class<? extends Annotation> qualifier : qualifiers) {
              //如果配置了@Primary 注解， 设置该 Bean 为 autowiring 自动依赖注入装//配时的首选
                if (Primary.class == qualifier) {
                  abd.setPrimary(true);
                }

                //如果配置了@Lazy 注解， 则设置该 Bean 为非延迟初始化， 如果没有配置，
                //则该 Bean 为预实例化
                else if (Lazy.class == qualifier) {
                  abd.setLazyInit(true);
                }
                else {
                //如果使用了除@Primary 和@Lazy 以外的其他注解， 则为该 Bean 添加一
                //个 autowiring 自动依赖注入装配限定符， 该 Bean 在进 autowiring
                //自动依赖注入装配时， 根据名称装配限定符指定的 Bean
                  abd.addQualifier(new AutowireCandidateQualifier(qualifier));
                }
              }
            }
            for (BeanDefinitionCustomizer customizer : definitionCustomizers) {
              customizer.customize(abd);
            }
            //创建一个指定 Bean 名称的 Bean 定义对象， 封装注解 Bean 定义类数据
            BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
            //根据注解 Bean 定义类中配置的作用域， 创建相应的代理对象
            definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
            //向 IOC 容器注册注解 Bean 类定义对象
            BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
          }
          #+END_SRC
          + resolveScopeMetadata --> org.springframework.context.annotation.AnnotationScopeMetadataResolver#resolveScopeMetadata
            #+BEGIN_SRC java
            //解析注解 Bean 定义类中的作用域元信息
            public ScopeMetadata resolveScopeMetadata(BeanDefinition definition) {
              ScopeMetadata metadata = new ScopeMetadata();
              if (definition instanceof AnnotatedBeanDefinition) {
                AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition;
                //从注解 Bean 定义类的属性中查找属性为”Scope”的值， 即@Scope 注解的值
                //annDef.getMetadata().getAnnotationAttributes 方法将 Bean中所有的注解和注解的值存放在一个 map 集合中
                AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(
                    annDef.getMetadata(), this.scopeAnnotationType);
                    //将获取到的@Scope 注解的值设置到要返回的对象中
                if (attributes != null) {
                  metadata.setScopeName(attributes.getString("value"));
                  //获取@Scope 注解中的 proxyMode 属性值， 在创建代理对象时会用到
                  ScopedProxyMode proxyMode = attributes.getEnum("proxyMode");
                  //如果@Scope 的 proxyMode 属性为 DEFAULT 或者 NO
                  if (proxyMode == ScopedProxyMode.DEFAULT) {

                  //设置 proxyMode 为 NO
                    proxyMode = this.defaultProxyMode;
                  }
                  metadata.setScopedProxyMode(proxyMode);
                }
              }
              //为返回的元数据设置 proxyMode
              return metadata;
            } 
            #+END_SRC
          + processCommonDefinitionAnnotations --> org.springframework.context.annotation.AnnotationConfigUtils#processCommonDefinitionAnnotations(AnnotatedBeanDefinition, AnnotatedTypeMetadata)
            #+BEGIN_SRC java
              static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata) {
                AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);
                if (lazy != null) {
                //如果 Bean 定义中有@Lazy 注解， 则将该 Bean 预实例化属性设置为@lazy 注解的值
                  abd.setLazyInit(lazy.getBoolean("value"));
                }
                else if (abd.getMetadata() != metadata) {
                  lazy = attributesFor(abd.getMetadata(), Lazy.class);
                  if (lazy != null) {
                    abd.setLazyInit(lazy.getBoolean("value"));
                  }
                }
                //如果 Bean 定义中有@Primary 注解， 则为该 Bean 设置为 autowiring 自动依赖注入装配的首选对象
                if (metadata.isAnnotated(Primary.class.getName())) {
                  abd.setPrimary(true);
                }

                //如果 Bean 定义中有@ DependsOn 注解， 则为该 Bean 设置所依赖的 Bean 名称，
                //容器将确保在实例化该 Bean 之前首先实例化所依赖的 Bean
                AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);
                if (dependsOn != null) {
                  abd.setDependsOn(dependsOn.getStringArray("value"));
                }

                AnnotationAttributes role = attributesFor(metadata, Role.class);
                if (role != null) {
                  abd.setRole(role.getNumber("value").intValue());
                }
                AnnotationAttributes description = attributesFor(metadata, Description.class);
                if (description != null) {
                  abd.setDescription(description.getString("value"));
                }
              } 
            #+END_SRC
          + applyScopedProxyMode --> org.springframework.context.annotation.AnnotationConfigUtils#applyScopedProxyMode
            #+BEGIN_SRC java
            //根据作用域为 Bean 应用引用的代码模式
              static BeanDefinitionHolder applyScopedProxyMode(
                  ScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry) {
                  //获取注解 Bean 定义类中@Scope 注解的 proxyMode 属性值
                ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode();
                //如果配置的@Scope 注解的 proxyMode 属性值为 NO， 则不应用代理模式
                if (scopedProxyMode.equals(ScopedProxyMode.NO)) {
                  return definition;
                }
                //获取配置的@Scope 注解的 proxyMode 属性值， 如果为 TARGET_CLASS
                //则返回 true， 如果为 INTERFACES， 则返回 false
                boolean proxyTargetClass = scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS);
                return ScopedProxyCreator.createScopedProxy(definition, registry, proxyTargetClass);
              } 
            #+END_SRC
          + registerBeanDefinition --> org.springframework.beans.factory.support.BeanDefinitionReaderUtils#registerBeanDefinition
        + scan(扫描包) --> org.springframework.context.annotation.ClassPathBeanDefinitionScanner#scan
          #+BEGIN_SRC java
            //为容器创建一个类路径 Bean 定义扫描器， 并指定是否使用默认的扫描过滤规则。
            //即 Spring 默认扫描配置： @Component、 @Repository、 @Service、 @Controller
            //注解的 Bean， 同时也支持 JavaEE6 的@ManagedBean 和 JSR-330 的@Named 注解
            public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters) {
              this(registry, useDefaultFilters, getOrCreateEnvironment(registry));
            }

            public int scan(String... basePackages) {
            //获取容器中已经注册的 Bean 个数
              int beanCountAtScanStart = this.registry.getBeanDefinitionCount();

              //启动扫描器扫描给定包
              doScan(basePackages);

              // Register annotation config processors, if necessary.
              //注册注解配置(Annotation config)处理器
              if (this.includeAnnotationConfig) {
                AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
              }
              //返回注册的 Bean 个数 
              return (this.registry.getBeanDefinitionCount() - beanCountAtScanStart);
            } 
          #+END_SRC
          + doscan
            #+BEGIN_SRC java
            /**
              * Perform a scan within the specified base packages,
              * returning the registered bean definitions.
              * <p>This method does <i>not</i> register an annotation config processor
              * but rather leaves this up to the caller.
              * @param basePackages the packages to check for annotated classes
              * @return set of beans registered if any for tooling registration purposes (never {@code null})
              */
              protected Set<BeanDefinitionHolder> doScan(String... basePackages) {
                Assert.notEmpty(basePackages, "At least one base package must be specified");
                //创建一个集合， 存放扫描到 Bean 定义的封装类
                Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();
                //遍历扫描所有给定的包
                for (String basePackage : basePackages) {
                //调用父类 ClassPathScanningCandidateComponentProvider 的方法
                //扫描给定类路径， 获取符合条件的 Bean 定义
                  Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
                  //遍历扫描到的 Bean
                  for (BeanDefinition candidate : candidates) {
                  //获取 Bean 定义类中@Scope 注解的值， 即获取 Bean 的作用域
                    ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);

                    //为 Bean 设置注解配置的作用域
                    candidate.setScope(scopeMetadata.getScopeName());
                    //为 Bean 生成名称
                    String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);

                    //如果扫描到的 Bean 不是 Spring 的注解 Bean， 则为 Bean 设置默认值，
                    //设置 Bean 的自动依赖注入装配属性等
                    if (candidate instanceof AbstractBeanDefinition) {
                      postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
                    }

                    //如果扫描到的 Bean 是 Spring 的注解 Bean， 则处理其通用的 Spring 注解
                    if (candidate instanceof AnnotatedBeanDefinition) {
                    //处理注解 Bean 中通用的注解， 在分析注解 Bean 定义类读取器时已经分析过
                      AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
                    }

                    //根据 Bean 名称检查指定的 Bean 是否需要在容器中注册， 或者在容器中冲突
                    if (checkCandidate(beanName, candidate)) {
                      BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
                      //根据注解中配置的作用域， 为 Bean 应用相应的代理模式
                      definitionHolder =
                          AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
                      beanDefinitions.add(definitionHolder);
                      //向容器注册扫描到的 Bean
                      registerBeanDefinition(definitionHolder, this.registry);
                    }
                  }
                }
                return beanDefinitions;
              }

            #+END_SRC
          + findCandidateComponents --> org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#findCandidateComponents
            #+BEGIN_SRC java
            //保存过滤规则要包含的注解， 即 Spring 默认的@Component、 @Repository、 @Service、
              private final List<TypeFilter> includeFilters = new LinkedList<>();

              //保存过滤规则要排除的注解
              private final List<TypeFilter> excludeFilters = new LinkedList<>();

              //向容器注册过滤规则
              protected void registerDefaultFilters() {
              //向要包含的过滤规则中添加@Component 注解类， 注意 Spring 中@Repository
              //@Service 和@Controller 都是 Component， 因为这些注解都添加了@Component 注解
                this.includeFilters.add(new AnnotationTypeFilter(Component.class));
                //获取当前类的类加载器
                ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();
                try {
                //向要包含的过滤规则添加 JavaEE6 的@ManagedBean 注解
                  this.includeFilters.add(new AnnotationTypeFilter(
                      ((Class<? extends Annotation>) ClassUtils.forName("javax.annotation.ManagedBean", cl)), false));
                  logger.trace("JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning");
                }
                catch (ClassNotFoundException ex) {
                  // JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.
                }
                try {
                //向要包含的过滤规则添加@Named 注解
                  this.includeFilters.add(new AnnotationTypeFilter(
                      ((Class<? extends Annotation>) ClassUtils.forName("javax.inject.Named", cl)), false));
                  logger.trace("JSR-330 'javax.inject.Named' annotation found and supported for component scanning");
                }
                catch (ClassNotFoundException ex) {
                  // JSR-330 API not available - simply skip.
                }
              }

              private Set<BeanDefinition> addCandidateComponentsFromIndex(CandidateComponentsIndex index, String basePackage) {
              //创建存储扫描到的类的集合
                Set<BeanDefinition> candidates = new LinkedHashSet<>();
                try {
                  Set<String> types = new HashSet<>();
                  for (TypeFilter filter : this.includeFilters) {
                    String stereotype = extractStereotype(filter);
                    if (stereotype == null) {
                      throw new IllegalArgumentException("Failed to extract stereotype from "+ filter);
                    }
                    types.addAll(index.getCandidateTypes(basePackage, stereotype));
                  }
                  boolean traceEnabled = logger.isTraceEnabled();
                  boolean debugEnabled = logger.isDebugEnabled();
                  for (String type : types) {
                  //为指定资源获取元数据读取器， 元信息读取器通过汇编(ASM)读//取资源元信息
                    MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(type);
                    //如果扫描到的类符合容器配置的过滤规则
                    if (isCandidateComponent(metadataReader)) {
                    //通过汇编(ASM)读取资源字节码中的 Bean 定义元信息
                      AnnotatedGenericBeanDefinition sbd = new AnnotatedGenericBeanDefinition(
                          metadataReader.getAnnotationMetadata());
                      if (isCandidateComponent(sbd)) {
                        if (debugEnabled) {
                          logger.debug("Using candidate component class from index: " + type);
                        }
                        candidates.add(sbd);
                      }
                      else {
                        if (debugEnabled) {
                          logger.debug("Ignored because not a concrete top-level class: " + type);
                        }
                      }
                    }
                    else {
                      if (traceEnabled) {
                        logger.trace("Ignored because matching an exclude filter: " + type);
                      }
                    }
                  }
                }
                catch (IOException ex) {
                  throw new BeanDefinitionStoreException("I/O failure during classpath scanning", ex);
                }
                return candidates;
              }

              //判断元信息读取器读取的类是否符合容器定义的注解过滤规则
              protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {
              //如果读取的类的注解在排除注解过滤规则中， 返回 false
                for (TypeFilter tf : this.excludeFilters) {
                  if (tf.match(metadataReader, getMetadataReaderFactory())) {
                    return false;
                  }
                }
                //如果读取的类的注解在包含的注解的过滤规则中， 则返回 ture
                for (TypeFilter tf : this.includeFilters) {
                  if (tf.match(metadataReader, getMetadataReaderFactory())) {
                    return isConditionMatch(metadataReader);
                  }
                }

                return false;
              }

              public Set<BeanDefinition> findCandidateComponents(String basePackage) {
                if (this.componentsIndex != null && indexSupportsIncludeFilters()) {
                  return addCandidateComponentsFromIndex(this.componentsIndex, basePackage);
                }
                else {
                  return scanCandidateComponents(basePackage);
                }
              } 
            #+END_SRC
    + AnnotationConfigWebApplicationContext
      AnnotationConfigWebApplicationContext 是 AnnotationConfigApplicationContext 的 Web 版，它们对于注解 Bean 的注册和扫描是基本相同的， 但是 AnnotationConfigWebApplicationContext对注解 Bean 定义的载入稍有不同， AnnotationConfigWebApplicationContext 注入注解 Bean 定义
      #+BEGIN_SRC java
        public class AnnotationConfigWebApplicationContext extends AbstractRefreshableWebApplicationContext
              implements AnnotationConfigRegistry {

              //载入注解 Bean 定义资源
            @Override
            protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) {
            //为容器设置注解 Bean 定义读取器
              AnnotatedBeanDefinitionReader reader = getAnnotatedBeanDefinitionReader(beanFactory);

              //为容器设置类路径 Bean 定义扫描器
              ClassPathBeanDefinitionScanner scanner = getClassPathBeanDefinitionScanner(beanFactory);

              //获取容器的 Bean 名称生成器
              BeanNameGenerator beanNameGenerator = getBeanNameGenerator();

              //为注解 Bean 定义读取器和类路径扫描器设置 Bean 名称生成器
              if (beanNameGenerator != null) {
                reader.setBeanNameGenerator(beanNameGenerator);
                scanner.setBeanNameGenerator(beanNameGenerator);
                beanFactory.registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator);
              }

              //获取容器的作用域元信息解析器
              ScopeMetadataResolver scopeMetadataResolver = getScopeMetadataResolver();
              //为注解 Bean 定义读取器和类路径扫描器设置作用域元信息解析器
              if (scopeMetadataResolver != null) {
                reader.setScopeMetadataResolver(scopeMetadataResolver);
                scanner.setScopeMetadataResolver(scopeMetadataResolver);
              }

              if (!this.annotatedClasses.isEmpty()) {
                if (logger.isDebugEnabled()) {
                  logger.debug("Registering annotated classes: [" +
                      StringUtils.collectionToCommaDelimitedString(this.annotatedClasses) + "]");
                }
                reader.register(ClassUtils.toClassArray(this.annotatedClasses));
              }

              if (!this.basePackages.isEmpty()) {
                if (logger.isDebugEnabled()) {
                  logger.debug("Scanning base packages: [" +
                      StringUtils.collectionToCommaDelimitedString(this.basePackages) + "]");
                }
                scanner.scan(StringUtils.toStringArray(this.basePackages));
              }

              //获取容器定义的 Bean 定义资源路径
              String[] configLocations = getConfigLocations();
              //如果定位的 Bean 定义资源路径不为空
              if (configLocations != null) {
                for (String configLocation : configLocations) {
                  try {
                  //使用当前容器的类加载器加载定位路径的字节码类文件
                    Class<?> clazz = ClassUtils.forName(configLocation, getClassLoader());
                    if (logger.isTraceEnabled()) {
                      logger.trace("Registering [" + configLocation + "]");
                    }
                    reader.register(clazz);
                  }
                  catch (ClassNotFoundException ex) {
                    if (logger.isTraceEnabled()) {
                      logger.trace("Could not load class for config location [" + configLocation +
                          "] - trying package scan. " + ex);
                    }
                    int count = scanner.scan(configLocation);
                    if (count == 0 && logger.isDebugEnabled()) {
                      logger.debug("No annotated classes found for specified class/package [" + configLocation + "]");
                    }
                  }
                }
              }
            }
          } 
      #+END_SRC
** ioc容器lazy-init
   + abstractapplicationcontext
      #+BEGIN_SRC java
      public abstract class AbstractApplicationContext extends DefaultResourceLoader
        implements ConfigurableApplicationContext { 
        @Override
        public void refresh() throws BeansException, IllegalStateException {
          synchronized (this.startupShutdownMonitor) {

            // Instantiate all remaining (non-lazy-init) singletons.
            //初始化所有剩余的单例Bean
            finishBeanFactoryInitialization(beanFactory);

            // Last step: publish corresponding event.
            //初始化容器的生命周期事件处理器，并发布容器的生命周期事件
            finishRefresh();
          }
        }
      }
      #+END_SRC
      在refresh()方法中ConfigurableListableBeanFactorybeanFactory = obtainFreshBeanFactory();启动了 Bean定义资源的载入、 注册过程， 而 finishBeanFactoryInitialization 方法是对注册后的 Bean 定义中的预实例化(lazy-init=false,Spring 默认就是预实例化,即为 true)的 Bean 进行处理的地方。
     + finishBeanFactoryInitialization
       #+BEGIN_SRC java
       //对配置了 lazy-init 属性的 Bean 进行预实例化处理
         protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
           // Initialize conversion service for this context.
           //这是 Spring3 以后新加的代码， 为容器指定一个转换服务(ConversionService)
           //在对某些 Bean 属性进行转换时使用
           if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&
               beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
             beanFactory.setConversionService(
                 beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
           }

           // Register a default embedded value resolver if no bean post-processor
           // (such as a PropertyPlaceholderConfigurer bean) registered any before:
           // at this point, primarily for resolution in annotation attribute values.
           if (!beanFactory.hasEmbeddedValueResolver()) {
             beanFactory.addEmbeddedValueResolver(strVal -> getEnvironment().resolvePlaceholders(strVal));
           }

           // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
           String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
           for (String weaverAwareName : weaverAwareNames) {
             getBean(weaverAwareName);
           }

           // Stop using the temporary ClassLoader for type matching.
           //为了类型匹配， 停止使用临时的类加载器
           beanFactory.setTempClassLoader(null);

           // Allow for caching all bean definition metadata, not expecting further changes.
           //缓存容器中所有注册的 BeanDefinition 元数据， 以防被修改
           beanFactory.freezeConfiguration();

           // Instantiate all remaining (non-lazy-init) singletons.
           //对配置了 lazy-init 属性的单态模式 Bean 进行预实例化处理
           beanFactory.preInstantiateSingletons();
         } 
       #+END_SRC
       + preInstantiateSingletons --> org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons
         #+BEGIN_SRC java
         	public void preInstantiateSingletons() throws BeansException {
            if (logger.isTraceEnabled()) {
              logger.trace("Pre-instantiating singletons in " + this);
            }

            // Iterate over a copy to allow for init methods which in turn register new bean definitions.
            // While this may not be part of the regular factory bootstrap, it does otherwise work fine.
            List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);

            // Trigger initialization of all non-lazy singleton beans...
            for (String beanName : beanNames) {
            //获取指定名称的 Bean 定义
              RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
              //Bean 不是抽象的， 是单态模式的， 且 lazy-init 属性配置为 false
              if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {

              //如果指定名称的 bean 是创建容器的 Bean
                if (isFactoryBean(beanName)) {
                //FACTORY_BEAN_PREFIX=”&”， 当 Bean 名称前面加”&”符号
                //时， 获取的是产生容器对象本身， 而不是容器产生的 Bean.
                //调用 getBean 方法， 触发容器对 Bean 实例化和依赖注入过程
                  Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
                  if (bean instanceof FactoryBean) {
                    final FactoryBean<?> factory = (FactoryBean<?>) bean;
                    //标识是否需要预实例化
                    boolean isEagerInit;
                    if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
                      isEagerInit = AccessController.doPrivileged((PrivilegedAction<Boolean>)
                              ((SmartFactoryBean<?>) factory)::isEagerInit,
                          getAccessControlContext());
                    }
                    else {
                      isEagerInit = (factory instanceof SmartFactoryBean &&
                          ((SmartFactoryBean<?>) factory).isEagerInit());
                    }
                    if (isEagerInit) {
                    //调用 getBean 方法， 触发容器对 Bean 实例化和依赖注入过程
                      getBean(beanName);
                    }
                  }
                }
                else {
                  getBean(beanName);
                }
              }
            }
            // Trigger post-initialization callback for all applicable beans...
            for (String beanName : beanNames) {
              Object singletonInstance = getSingleton(beanName);
              if (singletonInstance instanceof SmartInitializingSingleton) {
                final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
                if (System.getSecurityManager() != null) {
                  AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
                    smartSingleton.afterSingletonsInstantiated();
                    return null;
                  }, getAccessControlContext());
                }
                else {
                  smartSingleton.afterSingletonsInstantiated();
                }
              }
            }
          }
         #+END_SRC
         通过对 lazy-init 处理源码的分析， 我们可以看出， 如果设置了 lazy-init 属性， 则容器在完成 Bean定义的注册之后， 会通过 getBean 方法， 触发对指定 Bean 的初始化和依赖注入过程， 这样当应用第一次向容器索取所需的 Bean 时， 容器不再需要对 Bean 进行初始化和依赖注入， 直接从已经完成实例化和依赖注入的 Bean 中取一个现成的 Bean， 这样就提高了第一次获取 Bean 的性能。
** factorybean实现
    BeanFactory(管理)： Bean 工厂， 是一个工厂(Factory)， 我们 Spring IOC 容器的最顶层接口就是这个BeanFactory， 它的作用是管理 Bean， 即实例化、 定位、 配置应用程序中的对象及建立这些对象间的依赖。
    FactoryBean(生产)： 工厂 Bean， 是一个 Bean， 作用是产生其他 bean 实例。 通常情况下， 这种 bean 没有什么特别的要求， 仅需要提供一个工厂方法， 该方法用来返回其他 bean 实例。 通常情况下， bean 无须自己实现工厂模式， Spring 容器担任工厂角色； 但少数情况下， 容器中的 bean 本身就是工厂， 其作用是产生其它 bean 实例
    当用户使用容器本身时， 可以使用转义字符” &” 来得到 FactoryBean 本身， 以区别通过 FactoryBean产生的实例对象和 FactoryBean 对象本身。 在 BeanFactory 中通过如下代码定义了该转义字符：String FACTORY_BEAN_PREFIX = "&";如果 myJndiObject 是一个 FactoryBean， 则使用&myJndiObject 得到的是 myJndiObject 对象， 而不是 myJndiObject 产生出来的对象
